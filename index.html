<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chain Game v0.51</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #gameCanvas {
            border: 2px solid #666;
            background-color: #000;
        }
        #gameCanvas:fullscreen {
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1000" height="800"></canvas>

    <script>
        /*
         * Chain Game v0.29
         * Hold Up+Down arrow keys for 500ms to switch between collected music disks (including Silence)
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        const game = {
            cameraOffsetX: 0,
            cameraOffsetY: 0,
            zoom: 2.5,
            targetZoom: 2.5,
            baseZoom: 2.5,
            cameraShakeAmount: 0,
            paused: false,
            showAbilityDisplay: false,
            abilityDisplayTimer: 0,
            abilityDisplayDelay: 5.0,
            currentAbilityText: '',
            coinsCollected: 0,
            coinsDeposited: 0,
            hasHomeBeacon: false,
            hasWorkTools: false,
            hasMaxFulfillmentCoin: false,
            maxFulfillmentBoostActive: false,
            hasAirOfConfidence: false,
            userHasInteracted: false, // Prevents music until player presses arrow key
            nearbyNpc: null,
            keys: {
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false,
                r: false,
                R: false
            },
            keysPressed: {
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false
            }
        };

        // Jobs system state
        const jobs = {
            hasCourier: false,
            hasSorter: false,
            courierDeliveriesToday: 0,
            courierLastResetDate: null,
            sorterLastResetDate: null,
            currentPackage: null,
            packageDeadline: null,
            sortedToday: false,
            retrievedToday: false
        };

        // Dialogue state
        const dialogue = {
            active: false,
            npc: null,
            currentPage: 0,
            waitTimer: 0,
            waitDuration: 2.5,
            isWaiting: true,
            pendingChoice: false,
            choiceResult: null,
            showingDeclinedDialogue: false, // Track if showing declined dialogue after "no"
            showingNeedsWorkTools: false, // Track if showing needs work tools dialogue
            showingNoDiamondDialogue: false, // Track if showing Ram's no diamond dialogue
            lastNpc: null, // Track which NPC was just talked to
            cooldownTimer: 0
        };

        // Audio elements
        const audio = {
            pickupSounds: [
                new Audio('sfx/pickup_00.wav'),
                new Audio('sfx/pickup_01.wav'),
                new Audio('sfx/pickup_02.wav')
            ],
            receivedGift: new Audio('sfx/received-gift_soundimpact.wav'),
            movingSound: new Audio('sfx/draggingsmallchain.wav'),
            depositCoin: new Audio('sfx/pull-chain-02.wav'),
            depositSpecial: new Audio('sfx/deposit_special.wav')
        };

        // Initialize audio
        audio.movingSound.loop = true;
        audio.movingSound.volume = 0.3;

        // Music points system
        const musicPoints = [];
        const MUSIC_MIN_DB = -42;
        const MUSIC_MAX_DB = -0;

        function addMusicPoint(x, y, trackPaths, range = 1000, diskName = '') {
            // Create audio elements for each track
            const audioTracks = trackPaths.map(path => {
                const audio = new Audio(path);
                audio.volume = 0;
                // For multi-track sequences, set up event listener to play next track
                return audio;
            });

            const musicPoint = {
                x: x,
                y: y,
                audioTracks: audioTracks,
                currentTrackIndex: 0,
                currentVolume: 0,
                started: false,
                range: range,
                diskName: diskName
            };

            // Set up sequential playback for multi-track disks
            audioTracks.forEach((audio, index) => {
                audio.addEventListener('ended', () => {
                    // Play next track, or loop back to first (only after user interaction)
                    const nextIndex = (index + 1) % audioTracks.length;
                    if (musicPoint.started && musicPoint.currentVolume > 0 && game.userHasInteracted) {
                        musicPoint.currentTrackIndex = nextIndex;
                        audioTracks[nextIndex].currentTime = 0;
                        audioTracks[nextIndex].play().catch(e => console.log('Music play failed:', e));
                    }
                });
            });

            musicPoints.push(musicPoint);
            return musicPoint;
        }

        function updateMusicVolumes() {
            for (let point of musicPoints) {
                const dx = player.x - point.x;
                const dy = player.y - point.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Calculate volume based on distance using this point's range
                let targetVolume = 0;
                if (dist < point.range) {
                    const distRatio = dist / point.range;
                    const db = MUSIC_MAX_DB - (distRatio * (MUSIC_MAX_DB - MUSIC_MIN_DB));
                    targetVolume = Math.pow(10, db / 20);
                }

                point.currentVolume = Math.max(0, Math.min(1, targetVolume));

                // Update volume for all tracks
                point.audioTracks.forEach(audio => {
                    audio.volume = point.currentVolume;
                });

                // Start playing first track if not started and volume > 0 (only after user interaction)
                if (!point.started && point.currentVolume > 0 && game.userHasInteracted) {
                    point.audioTracks[0].play().catch(e => console.log('Music play failed:', e));
                    point.started = true;
                }

                // Stop all tracks if volume is 0
                if (point.started && point.currentVolume === 0) {
                    point.audioTracks.forEach(audio => {
                        audio.pause();
                    });
                    point.started = false;
                    point.currentTrackIndex = 0;
                }
            }
        }

        // Switch to next disk in collection (including Silence)
        function switchDisk() {
            // Cycle to next disk
            currentDiskIndex++;

            // If we've gone past all disks, go to silence (-1)
            // Silence is represented by currentDiskIndex = collectedDisks.length
            if (currentDiskIndex > collectedDisks.length) {
                currentDiskIndex = 0; // Wrap back to first disk
            }

            // Clear any existing music at post
            for (let i = musicPoints.length - 1; i >= 0; i--) {
                if (musicPoints[i].x === post.x && musicPoints[i].y === post.y) {
                    musicPoints[i].audioTracks.forEach(audio => audio.pause());
                    musicPoints.splice(i, 1);
                }
            }

            // If not silence, add the selected disk
            if (currentDiskIndex < collectedDisks.length) {
                const disk = collectedDisks[currentDiskIndex];
                addMusicPoint(post.x, post.y, disk.trackPaths, 3000, disk.name);
            }
            // If currentDiskIndex === collectedDisks.length, that's silence - no music plays

            // Save the selection
            saveGame();
        }

        // Track if player is currently moving for sound
        let isMoving = false;
        let lastDropTime = 0; // Prevent rapid dropping
        let dropHoldStartTime = null; // Track when player started holding drop keys

        // Check if a world position is visible on screen
        function isOnScreen(worldX, worldY) {
            const screen = worldToScreen(worldX, worldY);
            const margin = 100; // Extra margin to start timer before fully visible
            return screen.x >= -margin && screen.x <= canvas.width + margin &&
                   screen.y >= -margin && screen.y <= canvas.height + margin;
        }

        // Drop last picked up item
        function dropLastItem() {
            const currentTime = Date.now();
            if (currentTime - lastDropTime < 500) return; // 500ms cooldown
            lastDropTime = currentTime;

            // Try to drop an item first, then a coin
            if (player.carryingItems.length > 0) {
                const droppedItem = player.carryingItems.pop();

                // Place item near player with random offset
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                const dropX = player.x + Math.cos(angle) * distance;
                const dropY = player.y + Math.sin(angle) * distance;

                // Place item on ground (preserving all properties)
                droppedItems.push({
                    x: dropX,
                    y: dropY,
                    radius: 8,
                    color: '#000',
                    outlineColor: '#fff',
                    collected: false,
                    item: droppedItem
                });
            } else if (player.carryingCoins.length > 0) {
                const droppedCoin = player.carryingCoins.pop();

                // Track that coins were dropped (for Straum's dialogue)
                playerDroppedCoins = true;

                // Place coin near player with random offset
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                droppedCoin.x = player.x + Math.cos(angle) * distance;
                droppedCoin.y = player.y + Math.sin(angle) * distance;
                droppedCoin.collected = false;

                // Ensure coin is in the coins array (NPC-given coins aren't in the array initially)
                if (!coins.includes(droppedCoin)) {
                    coins.push(droppedCoin);
                }

                game.coinsCollected--;
            }
        }

        // Player stat modifiers from skills
        const modifiers = {
            moveSpeed: 0,
            moveAcceleration: 0,
            moveDeceleration: 0,
            carrySpeedPenaltyReduction: 0,
            carrySpeedBonus: 0,
            carryCapacity: 1,
            pickupRange: 0,
            zoomOut: 0,
            cameraOffsetReduction: 0
        };

        // Check if Max Fulfillment boost should be active (10+ weight carried)
        function updateMaxFulfillmentBoost() {
            if (!game.hasMaxFulfillmentCoin) {
                game.maxFulfillmentBoostActive = false;
                return;
            }

            // Calculate total weight (coins + item weights)
            let totalWeight = player.carryingCoins.length;
            for (let item of player.carryingItems) {
                totalWeight += item.slowAmount || 1;
            }

            game.maxFulfillmentBoostActive = totalWeight >= 10;
        }

        // Floating text effects
        const floatingTexts = [];

        // Post (center of world)
        const post = {
            x: 0,
            y: 0,
            baseRadius: 15,
            radius: 15,
            color: '#fff',
            alpha: 1.0,
            pulseTime: 0
        };

        // Player
        const player = {
            x: 0,
            y: 20,
            vx: 0,
            vy: 0,
            radius: 12,
            color: '#000',
            outlineColor: '#fff',
            baseSpeed: 2,
            baseSlowSpeed: 1,
            baseAcceleration: 0.3,
            baseDeceleration: 0.85,
            carryingCoins: [],
            carryingItems: [] // For NPC items
        };

        // NPCs
        const npcs = [
            {
                name: 'Tim',
                x: 150,
                y: 150,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Hey there! Just got here, huh?", "Look... just stay out of trouble.", "But if thing's get heavy..."],
                    ["Press Left and Right arrows at the same time", "to drop the last item you picked up.", "Simple, right?"],
                    ["Here, take this Ish.", "It'll help you carry more stuff,", "once you deposit it."]
                ],
                workToolsDialogue: [
                    ["Hey, you're back! Oh… a job!", "Of course, I should've given this to you before!"]
                ],
                workToolsCompletedDialogue: [
                    ["Good luck! Chain is looking great by the way,", "at this rate you'll meet Ob in no time…", "though I'd enjoy it while it lasts!"]
                ],
                fullDialogue: [
                    ["Hey, are you new?,", "I can help you out.", "Come back when your hands aren't full."]
                ],
                completedDialogue: [
                    ["Remember: Left+Right to drop extra weight!", "Sometimes we have to let go."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                workToolsGiven: false,
                needsWorkTools: false,
                requiresCoins: 0,
                itemType: 'ability',
                abilityName: 'Small Bag +1 Capacity',
                abilityEffect: () => { modifiers.carryCapacity += 1; }
            },
            {
                name: 'Gary',
                x: -150,
                y: 200,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Man… I dropped all these coins,", "but I'm too lazy to pick them up.", "I saw you already take some..."],
                    ["So I guess… you can have them if you want.", "Dang."]
                ],
                completedDialogue: [
                    ["Yeah, take all the coins.", "I don't care anymore."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: null
            },
            {
                name: 'Wes',
                x: 150,
                y: -250,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Nice Chain!", "I've got this Diamond I don't need,", "you should have it!"],
                    ["Do you want to take it?", "(Up for yes, Down for no)"]
                ],
                fullDialogue: [
                    ["I'd give you this sweet Diamond,", "but it looks like you've got", "your hands full."]
                ],
                completedDialogue: [
                    ["Glad you took that Diamond off my hands.", "Hope it wasn't too heavy."]
                ],
                declinedDialogue: [
                    ["No worries!", "Let me know if you want this Diamond later."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: 'diamond',
                hasChoice: true,
                endOnAccept: true // Close dialogue immediately after accepting
            },
            {
                name: 'Sam',
                x: -300,
                y: -450,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Hey there, slick Chain!", "I'd love to run around,", "but my knees don't work good."],
                    ["I've got this Quick Quick for sale.", "Just 3 coins and it's yours.", "Do you want it? (Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Great! Bring me the keesh.", "I need X more coins.", "Don't come back until you have them."]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had cool stuff for you too.", "Dagnabit."]
                ],
                declinedDialogue: [
                    ["No problem!", "Let me know if you change your mind."]
                ],
                completedDialogue: [
                    ["I wish my knees didn't hurt.", "Then, I could run real fast again. *knees crack*"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 3,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Speed Boost',
                abilityEffect: () => { modifiers.moveSpeed += 0.40; },
                hasChoice: true
            },
            {
                name: 'Chris',
                x: 350,
                y: 250,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["You! Nice Chain!", "Here, take this Thang."],
                    ["It'll let you hold way more stuff.", "Carry on!"]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had rad stuff for you too.", "Butts."]
                ],
                completedDialogue: [
                    ["I miss when I had a Chain.", "Now I got nothin' to do!"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: 'ability',
                abilityName: 'Carry Capacity +10',
                abilityEffect: () => { modifiers.carryCapacity += 10; }
            },
            {
                name: 'Zoe',
                x: -500,
                y: 500,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Still looking at everything all close up, huh?", "Broaden your horizons.", "I've got just the thing."],
                    ["This Perspective Token is 3 coins.", "Do you want it?", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Perfect! Bring me the cheese.", "I need X more coins.", "Come back when you have them coins."]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had neat stuff for you too.", "Darn."]
                ],
                declinedDialogue: [
                    ["Dumb choice!", "Come back if you get smart."]
                ],
                completedDialogue: [
                    ["Nobody has any perspective nowadays.", "As if there's only one way to look at things."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 3,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Zoom Out 20%',
                abilityEffect: () => { modifiers.zoomOut += 0.20; },
                hasChoice: true
            },
            // {
            //     name: 'Maria',
            //     x: 1350,
            //     y: -500,
            //     radius: 12,
            //     color: '#000',
            //     outlineColor: '#fff',
            //     dialogue: [
            //         ["I've got a neat gadget gizmo whatchamacallit?", "neato bonito, superdee duperdee...", "I've got a Magnet Coin for sale."],
            //         ["It's 10 coins.", "Do you want it, yes or no?", "(Up for yes, Down for no)"]
            //     ],
            //     collectingDialogue: [
            //         ["Excellent choice! Bring me those tasty coins.", "I need X more of em' thangs.", "It'll be worth it, trust me!"]
            //     ],
            //     fullDialogue: [
            //         ["Looks like you have your hands full,", "and I had rad stuff for you too.", "Shucks."]
            //     ],
            //     declinedDialogue: [
            //         ["Your loss!", "I didn't even want you to buy it anyway."]
            //     ],
            //     completedDialogue: [
            //         ["Yeah it's not that good.", "Sorry about that!"]
            //     ],
            //     itemGiven: false,
            //     hasCompletedQuest: false,
            //     requiresCoins: 10,
            //     coinsCollected: 0,
            //     isCollecting: false,
            //     itemType: 'ability',
            //     abilityName: 'Pickup Range +100%',
            //     abilityEffect: () => { modifiers.pickupRange += 1.00; },
            //     hasChoice: true
            // },
            {
                name: 'Ron',
                x: -600,
                y: -350,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["SPEED! That's what it's all about!", "You need more SPEED!", "I've got a The Good Stuff!"],
                    ["Just 5 coins!", "Do you want it?!", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["YES! Bring me those coins!", "I need X more coins!", "SPEED AWAITS!"]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had wild stuff for you too.", "Buh."]
                ],
                declinedDialogue: [
                    ["WHAT?! Your loss!", "Come back when you want SPEED!"]
                ],
                completedDialogue: [
                    ["YEAH! Feel that speed!", "AMAZING!"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 5,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Turbo Speed +50%',
                abilityEffect: () => { modifiers.moveSpeed += 0.50; },
                hasChoice: true
            },
            {
                name: 'Bob',
                x: 4,
                y: 550,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Carrying coins slowing you down?", "Not anymore!", "I've got Just The Thing."],
                    ["Just 3 coins.", "Do you wanna snag this puppy or what?", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Smart choice! Bring me the coinage.", "I need X more of dem shinies.", "You'll love this ring!"]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had sweet stuff for you too.", "Darn."]
                ],
                declinedDialogue: [
                    ["Alright then.", "Let me know if you stop being dumb."]
                ],
                completedDialogue: [
                    ["Sometimes the weight is hard to carry without some help."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 3,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Carry Penalty -50%',
                abilityEffect: () => { modifiers.carrySpeedPenaltyReduction += 0.50; },
                hasChoice: true
            },
            /*{
                name: 'Sally',
                x: -500,
                y: 350,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Want to accelerate faster?", "Of course you do.", "Everyone does."],
                    ["I've got a Quick Start Token for 5 coins.", "Do you want it?", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Good decision! Bring me the coins.", "I need X more coins.", "Snappy acceleration awaits!"]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had mad stuff for you too.", "Whoops."]
                ],
                declinedDialogue: [
                    ["Okay then.", "Come back if you change your mind."]
                ],
                completedDialogue: [
                    ["Maybe I should slow down...", "Nah, fast is better."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 5,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Acceleration +40%',
                abilityEffect: () => { modifiers.moveAcceleration += 0.40; },
                hasChoice: true
            },*/
            {
                name: 'Hank',
                x: 700,
                y: -850,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["I used to collect everything.", "EVERYTHING.", "But I'm downsizing now."],
                    ["Take this Neat Thing.", "It holds like... a lot.", "You'll love it."]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had maxed out stuff for you too.", "Darn."]
                ],
                completedDialogue: [
                    ["People think I'm a hoarder.", "But I just like collecting stuff."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: 'ability',
                abilityName: 'Carry Capacity +15',
                abilityEffect: () => { modifiers.carryCapacity += 15; }
            },
           /* {
                name: 'Cal',
                x: -400,
                y: -1250,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["That camera wobbling around", "when you move bothers me.", "Here, take this Stabilizer."],
                    ["Now you can actually see", "where you're going!"]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had cool stuff for you too.", "Darn."]
                ],
                completedDialogue: [
                    ["Stable view?", "You're welcome!"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: 'ability',
                abilityName: 'Camera Stability',
                abilityEffect: () => { modifiers.cameraOffsetReduction = 1.0; }
            },*/
            {
                name: 'Eddie',
                x: 550,
                y: -200,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["You know what's weird?", "THIS!", "I'll sell it to you!"],
                    ["Yeah, buy THIS, for 6 coins.", "Wanna buy it, yeah?", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Awesome! Bring me the coins.", "I need X more of them coins.", "Weird power awaits!"]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had bananas stuff for you too.", "Weiners."]
                ],
                declinedDialogue: [
                    ["No you've gotta buy it.", "You said you'd buy it!"]
                ],
                completedDialogue: [
                    ["You know what else is weird?", "The game SAVES whenever you deposit something at your post.", "Told you it was weird!"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 6,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Carry Speed Bonus +30%',
                abilityEffect: () => { modifiers.carrySpeedBonus += 0.30; },
                hasChoice: true
            },
            {
                name: 'Quincy',
                x: -2599,
                y: -2129,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Oh, nice to see someone friendly.", "I'm basically done doing anything at this point", "Feels like someone put me way out here and forgot about me."],
                    ["Anyway, I've got the Feeling Of Fulfillment.", "Carry enough weight and you'll feel better.", "15 coins.", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Yeah, bring me those coins.", "I need X more.", "I'll just wait here. In the void. Alone."]
                ],
                fullDialogue: [
                    ["Looks like you can't carry anything else...", "Otherwise I'd sell you something", "Come back when you've got room."]
                ],
                declinedDialogue: [
                    ["You walked ALL the way out here...", "just to say no?", "Respect, honestly."]
                ],
                completedDialogue: [
                    ["Sometimes I feel like I still have my Chain..."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 15,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Max Fulfillment Coin',
                abilityEffect: () => { game.hasMaxFulfillmentCoin = true; },
                hasChoice: true
            },
            /*{
                name: 'Betty',
                x: -1650,
                y: 500,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Lost? Can't find your way home?", "Me neither.", "I've got a Home Beacon Token but I haven't had a Chain for a long time."],
                    ["Just 10 coins and it's yours.", "Do you want it?", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Great! Bring me the gnosh.", "I need X more coins.", "You'll never get lost again!"]
                ],
                fullDialogue: [
                    ["Looks like you have your hands full,", "and I had a cool thing to sell you too.", "Bummer."]
                ],
                declinedDialogue: [
                    ["Suit yourself.", "Come back if you change your mind."]
                ],
                completedDialogue: [
                    ["I wish I could go back home."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 10,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'homeBeacon',
                hasChoice: true
            },*/
            {
                name: 'George',
                x: 0,
                y: -1000,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Still on the Chain huh?", "You like my music?", "Well you definitely need some tunes."],
                    ["Don't worry, I won't charge you nothin',", "music is a necessity."]
                ],
                completedDialogue: [
                    ["You can hold Up and Down to change Disks. Cool, huh?"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: 'musicDisk',
                diskName: 'Chill Tune Disk',
                trackPaths: ['music/Chill Tune Disk/chilltune.wav']
            },
            {
                name: 'Fritz',
                x: 2000,
                y: 100,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["I've got a disk,", "but nothing to play it on.", "Dang."],
                    ["You wanna buy this joint off me?", "I'll let it go cheap cheap.", "Do you want it? (Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Great! Bring me the coins.", "I need X more coins.", "This disk is fire!"]
                ],
                declinedDialogue: [
                    ["Mannn, are you serious???"]
                ],
                completedDialogue: [
                    ["I bet you didn't even know,", "you can hold Up and Down to change Disks."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 3,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'musicDisk',
                diskName: 'Going Places',
                trackPaths: ['music/Echoes/b01_suncity.mp3', 'music/Echoes/b02_highlife.mp3'],
                hasChoice: true
            },
            {
                name: 'Jawn',
                x: -2000,
                y: -600,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["So uh… funny story.", "I've got this stinkin' Disk,", "and normally I'd give it away but…"],
                    ["Gonna need 3 coins for it.", "I can't just give it away, y'know?", "Do you want it? (Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Yo! Coming back with the goods?", "I need X more coins.", "You can hold Up and Down to change Disks, by the way!"]
                ],
                fullDialogue: [
                    ["Bruh, you're carrying like… everything.", "Drop some stuff and come back.", "I'll be here. Obviously."]
                ],
                declinedDialogue: [
                    ["Alright, alright, I feel you.", "But like… it's a brisk track though.", "Your loss?"]
                ],
                completedDialogue: [
                    ["Nice... nice...", "Thanks for funding my… uh…", "What DO I spend coins on?"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 3,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'musicDisk',
                diskName: 'GAMBLIN MAN',
                trackPaths: ['music/GAMBLIN MAN/Noam - GAMBLIN MAN (67 BPM).wav'],
                hasChoice: true
            },
            {
                name: 'Klaus',
                x: 4500,
                y: -60,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Oh hey, a visitor!", "Welcome to the middle of nowhere.", "I just stand here and vibe to music all day."],
                    ["You want my disk? Hah. No.", "I don't know you like that.", "Come back when you've done something impressive."]
                ],
                pinReadyDialogue: [
                    ["Hey, I heard you've been helping my buddy Pin.", "Ever since Pin showed up, I'm not alone anymore.", "It's nice having company."],
                    ["You can have this Disk, I don't need it anymore."]
                ],
                completedDialogue: [
                    ["Hey, friend."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: 'musicDisk',
                diskName: 'Cache Full Disk',
                trackPaths: [
                    'music/CacheFull/Angelic.wav',
                    'music/CacheFull/Disk.wav',
                    'music/CacheFull/Moonlit.wav',
                    'music/CacheFull/Panther.wav',
                    'music/CacheFull/Sum err.wav',
                    'music/CacheFull/blu icee.wav',
                    'music/CacheFull/dicsker.wav',
                    'music/CacheFull/downbound.wav',
                    'music/CacheFull/wet n deep.wav'
                ]
            },
            {
                name: 'Noodles',
                x: -4500,
                y: -4060,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Oh look, still on a Chain huh?.", "How original.", "Let me guess - you want something from me?"],
                    ["I've got this disk, see.", "12 tracks of pure vibes.", "But I'm not just handing it to some baby Chained tourist."],
                    ["Come back when your Chain's getting ready to come off.", "You can hang out and listen here for now...", "If you want..."]
                ],
                linksReadyDialogue: [
                    ["Well well well.", "You actually did it.", "I'd slow clap but I don't have arms."],
                    ["Alright, you've earned my respect.", "And my disk.", "Take good care of it. These beats slap."]
                ],
                completedDialogue: [
                    ["The legend returns.", "Still grinding? Respect.", "You're the only player who made it this far, probably."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: 'musicDisk',
                diskName: 'BUDSbeats',
                trackPaths: [
                    'music/BUDSbeats/1 - buds intro.wav',
                    'music/BUDSbeats/2 - animace face (401k).wav',
                    'music/BUDSbeats/3 - animace face (soul).wav',
                    'music/BUDSbeats/4- DAWG WALKER  (light idea).wav',
                    'music/BUDSbeats/5 -  SUNSET SHERBERT (matrix).wav',
                    'music/BUDSbeats/7 - GSC  (morning groove).wav',
                    'music/BUDSbeats/8 - GG#4 (french joint).wav',
                    'music/BUDSbeats/9 - JET FUEL GELATO  (on 1).wav',
                    'music/BUDSbeats/10- WEDDING CAKE (stbg).wav',
                    'music/BUDSbeats/12 - MOON ROCKS  (owe u nothin).wav',
                    'music/BUDSbeats/13 - HANS SOLO BURGER (woohoo!).wav',
                    'music/BUDSbeats/14 - Buds Outro.wav'
                ]
            },
            {
                name: 'Straum',
                x: 1000,
                y: 1000,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Someone dropped their coins…", "so many coins! I picked them all up!", "It was fun!"],
                    ["I don't need em' though,", "since I don't have a Chain anymore…", "so… do you want em'?"]
                ],
                yesDialogue: [
                    ["Here little bud, all you can carry."]
                ],
                declinedDialogue: [
                    ["Ah, gotcha. I see you."]
                ],
                droppedCoinsDialogue: [
                    ["Make sure you pick up after yourself.", "You wouldn't want to lose your stuff."]
                ],
                outOfCoinsDialogue: [
                    ["That's all of em'.", "I also found this diamond.", "Do you want it?", "(Up for yes, Down for no)"]
                ],
                diamondYesDialogue: [
                    ["Here you go, bud."]
                ],
                diamondNoDialogue: [
                    ["Oh, is it too heavy for you, bud?"]
                ],
                completedDialogue: [
                    ["You know, I still feel like I have", "a Chain just like you.", "Isn't that weird, bud?"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                hasChoice: true,
                itemType: 'straum', // Special type for Straum's coin/diamond giving
                coinsInventory: 99,
                diamondGiven: false
            },
            {
                name: 'Chaff',
                x: 200,
                y: -2500,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Hey there, looks like you're making good", "progress on your Chain.", "You won't always just find coins on the ground though."],
                    ["Most people on the Chain have to get proper jobs.", "Not a lot of options though.", "You can either go west of here to find the Farm,"],
                    ["or you can go east to the Courier Service Depot.", "I wish I still had a reason to work."]
                ],
                completedDialogue: [
                    ["West for sorting, east for courier.", "Just don't go getting fired."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 0,
                itemType: null
            },
            {
                name: 'Wheaton',
                x: -2000,
                y: -2500,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Hey, a chain like that takes discipline.", "Ever think about working with animals?", "I need the help and I've got the coin… well coins… lots of them."],
                    ["Want a job as an animal retriever?", "(Up for yes, Down for no)"]
                ],
                declinedDialogue: [
                    ["Well, the position is open…", "come back if you change your mind."]
                ],
                needsWorkToolsDialogue: [
                    ["Excellent. Hmm.. but you don't have", "the proper job-having equipment.", "You'll need to go to Tim and get yourself a Job-having Tools."],
                    ["His last post was pretty far Southeast of here.", "He was sent out to help out the newest member of the world."]
                ],
                retrievalDialogue: [
                    ["Animal retrieval is pretty easy.", "Just get close to them and they'll follow you.", "Bring them back to me."],
                    ["You'll find them scattered around around here somewhere."]
                ],
                activeJobDialogue: [
                    ["Good. Now your job is to make sure each group of", "animals gets brought back every day.", "New animals arrive at 18:00 once a day."],
                    ["You'll get your coins as soon", "as you deliver the animals."]
                ],
                completedDialogue: [
                    ["Good work. Looks like you got them all for today.", "We'll start again at 18:00."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                hasChoice: true,
                requiresCoins: 0,
                itemType: null,
                jobAccepted: false,
                firstRetrievalCompleted: false,
                allAnimalsRetrieved: false
            },
            {
                name: 'Weadon',
                x: 2100,
                y: -2400,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Hey, looks like you're getting", "a good start on that Chain eh.", "You must be used to traveling."],
                    ["I need some help with this courier biz.", "Want a job in the delivery service?", "(Up for yes, Down for no)"]
                ],
                declinedDialogue: [
                    ["Hey! Jobs aren't always going to be available…", "don't complain if we find someone else."]
                ],
                needsWorkToolsDialogue: [
                    ["Excellent. Hmm... but you don't have", "the proper job-having equipment.", "You'll need to go to Tim and get yourself a job equipment token."],
                    ["His last post was pretty far Southwest of here.", "He was sent out to help our newest member."]
                ],
                firstPackageDialogue: [
                    ["Great. Let me explain this courier biz.", "I'm gonna give you a package.", "You take it to the whoever it belongs. That's the biz."]
                ],
                activeDeliveryDialogue: [
                    ["You have until TIME_PLACEHOLDER to do the biz. This package is for NPC_PLACEHOLDER."]
                ],
                completedDeliveriesDialogue: [
                    ["Three is all we need. Three a day.", "That's the biz. Come back tomorrow."]
                ],
                completedDialogue: [
                    ["Come back tomorrow for more deliveries.", "Three a day. That's the biz."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                hasChoice: true,
                requiresCoins: 0,
                itemType: null,
                jobAccepted: false,
                firstDeliveryMade: false,
                canReceivePackage: false
            },
            {
                name: 'Moe',
                x: 3500,
                y: 3200,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Sometimes more is more.", "Sometimes less is more.", "Sometimes more is less", "I wish I could use this Clarity, I'll sell it to you though..."]
                ],
                collectingDialogue: [
                    ["Yeah yeah, bring me the coins.", "I need X more.", "I'm not going anywhere. Obviously."]
                ],
                fullDialogue: [
                    ["Your inventory is full.", "Classic mistake.", "Come back when you've deposited."]
                ],
                declinedDialogue: [
                    ["You'll be back.", "They always come back."]
                ],
                completedDialogue: [
                    ["Now you can see how empty this world really is.", "You're welcome. I guess."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 6,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Zoom Out 20%',
                abilityEffect: () => { modifiers.zoomOut += 0.20; },
                hasChoice: true
            },
            {
                name: 'Don',
                x: -3800,
                y: -3400,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["You know Ron?", "That guy undersells. 5 coins? Please.", "I've got the REAL DEAL right here."],
                    ["10 coins! Same speed, premium price!", "You're paying for the ambiance."]
                ],
                collectingDialogue: [
                    ["COINS! Bring me COINS!", "I need X more!", "SPEED IS ALMOST YOURS!"]
                ],
                fullDialogue: [
                    ["Hands full? Rookie move.", "Deposit your stuff and come back.", "I'll wait."]
                ],
                declinedDialogue: [
                    ["SLOW! You're gonna stay SLOW!", "I respect that actually. No I don't."]
                ],
                completedDialogue: [
                    ["I don't move, but if I did...", "I'd be FAST!"]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 10,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Turbo Speed +50%',
                abilityEffect: () => { modifiers.moveSpeed += 0.50; },
                hasChoice: true
            },
            {
                name: 'Rob',
                x: -3200,
                y: 3800,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Let me guess - things getting too heavy?", "Can't barely take it anymore?", "I've some That Strong Stuff."],
                    ["6 coins. Non-negotiable.", "No funny business.", "(Up for yes, Down for no)"]
                ],
                collectingDialogue: [
                    ["Bring me the coins.", "X more to go.", "My coin collection grows."]
                ],
                fullDialogue: [
                    ["Inventory full.", "Did you even read the tutorial?", "...there's no tutorial? Huh."]
                ],
                declinedDialogue: [
                    ["Your back, your problem.", "See you in 5 minutes."]
                ],
                completedDialogue: [
                    ["Thanks for the Coin, Jack.", "I admire your commitment to the game."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresCoins: 6,
                coinsCollected: 0,
                isCollecting: false,
                itemType: 'ability',
                abilityName: 'Carry Penalty -50%',
                abilityEffect: () => { modifiers.carrySpeedPenaltyReduction += 0.50; },
                hasChoice: true
            },
            {
                name: 'Pin',
                x: 3033,
                y: -49,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Wow… your chain is so long… and mine…", "well… my post isn't near any coins…", "and nobody is around to help…"]
                ],
                tenLinksDialogue: [
                    ["Look how long my chain is getting!"]
                ],
                twentyLinksDialogue: [
                    ["I can't believe I'll finally get out into the world."]
                ],
                fiftyLinksDialogue: [
                    ["At this rate, I'll be as long as you soon!"]
                ],
                hundredLinksDialogue: [
                    ["Hey, I've come a long way and I know it's not a lot,", "but here you go!"]
                ],
                completedDialogue: [
                    ["I love my Chain!"]
                ],
                isChainedNPC: true,
                targetCoinIndex: -1,
                carryingCoin: null,
                returningToPost: false,
                diamondGiven: false
            },
            {
                name: 'Clint',
                x: 5000,
                y: 400,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["Oh.", "Someone's here."],
                    ["I've been standing here for... I don't know.", "Time doesn't mean much anymore."],
                    ["I had a home once.", "Or maybe I dreamed it.", "Hard to tell the difference now."],
                    ["You're going somewhere, aren't you?", "Must be nice. Having a direction.", "I just... exist here."],
                    ["Hey, um...", "Could I come with you?", "I don't want to be alone anymore.", "(Up for yes, Down for no)"]
                ],
                yesDialogue: [
                    ["Really?", "...thank you.", "I'll try not to slow you down."]
                ],
                declinedDialogue: [
                    ["Yeah.", "I figured.", "I wouldn't want me either."]
                ],
                followingDialogue: [
                    ["..."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                hasChoice: true,
                isFollower: true,
                isFollowing: false,
                followSide: 0 // -1 for left, 1 for right, determined when following starts
            },
            {
                name: 'Ram',
                x: -1474,
                y: 1819,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["What do you want.", "I've got something.", "Air of Confidence."],
                    ["Makes it so you can lead as many", "animals as you want.", "No limits."],
                    ["Costs a diamond.", "Not the fancy one. A regular diamond.", "(Up for yes, Down for no)"]
                ],
                noDiamondDialogue: [
                    ["You don't have a diamond.", "Come back when you do."]
                ],
                fullDialogue: [
                    ["Hmm... that long of a chain", "and still running out of space?", "Interesting... Come back when you get rid of some of that."]
                ],
                declinedDialogue: [
                    ["Whatever.", "Your loss."]
                ],
                completedDialogue: [
                    ["You've got it.", "Now get out of here."]
                ],
                itemGiven: false,
                hasCompletedQuest: false,
                requiresDiamond: true, // Special flag for diamond payment
                isCollectingDiamond: false, // Blink state when waiting for diamond
                itemType: 'ability',
                abilityName: 'Air of Confidence',
                abilityEffect: () => { game.hasAirOfConfidence = true; },
                hasChoice: true
            },
            {
                name: 'Brot',
                x: -4600,
                y: 3400,
                radius: 12,
                color: '#000',
                outlineColor: '#fff',
                dialogue: [
                    ["*sigh*", "Another day... another coin to collect...", "I'm so tired of this."],
                    ["500 links on my chain and for what?", "More coins? More walking?", "I just... I don't care anymore."],
                    ["You know what I really want?", "A pet. Something alive.", "Something that actually moves on its own."],
                    ["If you ever find any animals out there...", "bring them to me?", "I'll make it worth your while."]
                ],
                oneAnimalDialogue: [
                    ["Wait... is that... an animal?!", "A real, living, moving creature?!", "This is the best day of my entire chain life!"]
                ],
                fiveAnimalsDialogue: [
                    ["Five little friends!", "They're so... wiggly.", "I love watching them waddle around."]
                ],
                tenAnimalsDialogue: [
                    ["Ten animals! TEN!", "I'm practically a farmer now.", "Who needs coins when you have friends?"]
                ],
                twentyFiveAnimalsDialogue: [
                    ["Twenty-five?! You're kidding me.", "I never thought I'd see so many.", "Are you some kind of animal wizard?"]
                ],
                fiftyAnimalsDialogue: [
                    ["FIFTY ANIMALS!", "This is... this is everything.", "I have to give you something for this."],
                    ["Here, take this. I found it ages ago.", "It's heavy, but it's worth a fortune.", "Thank you... truly."]
                ],
                completedDialogue: [
                    ["Wow, I can't believe it...", "a real flock...", "I think I'll get back to working on my Chain now."]
                ],
                isChainedNPC: true,
                targetCoinIndex: -1,
                carryingCoin: null,
                returningToPost: false,
                animalsCollected: 0,
                itemGiven: false,
                hasCompletedQuest: false,
                refusesToCollectCoins: true, // Won't collect coins until quest complete
                itemType: 'diamond',
                itemName: 'Better Diamond',
                itemSlowAmount: 100 // Worth 100 coins, weighs 100
            }
        ];

        // Chain
        const chain = {
            links: 5,
            linkLength: 20,
            segments: []
        };

        // Pin's post (for chained NPC)
        const pinPost = {
            x: 3033,
            y: -49,
            baseRadius: 15,
            radius: 15,
            color: '#fff',
            alpha: 1.0,
            pulseTime: 0
        };

        // Pin's chain
        const pinChain = {
            links: 5,
            linkLength: 20,
            segments: []
        };

        // Brot's post (for chained NPC) - positioned toward player's start
        const brotPost = {
            x: -3040,
            y: -2780,
            baseRadius: 15,
            radius: 15,
            color: '#fff',
            alpha: 1.0,
            pulseTime: 0
        };

        // Brot's chain (starts with 500 links)
        const brotChain = {
            links: 500,
            linkLength: 20,
            segments: []
        };

        // Animals that have been captured by Brot (permanent)
        const brotAnimals = [];

        // Skill database
        const skills = {
            up: [
                { name: "Light Steps", desc: "+10% move speed", effect: () => { modifiers.moveSpeed += 0.10; } },
                { name: "Quick Pace", desc: "+15% move speed", effect: () => { modifiers.moveSpeed += 0.15; } },
                { name: "Swift Stride", desc: "+20% move speed", effect: () => { modifiers.moveSpeed += 0.20; } },
                { name: "Agile Runner", desc: "+25% move speed", effect: () => { modifiers.moveSpeed += 0.25; } },
                { name: "Speed Demon", desc: "+30% move speed", effect: () => { modifiers.moveSpeed += 0.30; } },
                { name: "Fast Acceleration", desc: "+20% acceleration", effect: () => { modifiers.moveAcceleration += 0.20; } },
                { name: "Nimble Response", desc: "+30% acceleration", effect: () => { modifiers.moveAcceleration += 0.30; } },
                { name: "Instant Reflex", desc: "+40% acceleration", effect: () => { modifiers.moveAcceleration += 0.40; } },
                { name: "Reduced Drag", desc: "-10% deceleration", effect: () => { modifiers.moveDeceleration -= 0.10; } },
                { name: "Air Brake", desc: "-20% deceleration", effect: () => { modifiers.moveDeceleration -= 0.20; } },
                { name: "Perfect Control", desc: "-30% deceleration", effect: () => { modifiers.moveDeceleration -= 0.30; } },
                { name: "Momentum Master", desc: "+15% speed, +15% accel", effect: () => { modifiers.moveSpeed += 0.15; modifiers.moveAcceleration += 0.15; } },
                { name: "Fleet Footed", desc: "+25% speed, +10% accel", effect: () => { modifiers.moveSpeed += 0.25; modifiers.moveAcceleration += 0.10; } },
                { name: "Lightning Legs", desc: "+35% speed, +20% accel", effect: () => { modifiers.moveSpeed += 0.35; modifiers.moveAcceleration += 0.20; } },
                { name: "Frictionless", desc: "+20% speed, -20% decel", effect: () => { modifiers.moveSpeed += 0.20; modifiers.moveDeceleration -= 0.20; } },
                { name: "Velocity Boost", desc: "+40% move speed", effect: () => { modifiers.moveSpeed += 0.40; } },
                { name: "Turbo Mode", desc: "+50% move speed", effect: () => { modifiers.moveSpeed += 0.50; } },
                { name: "Speed Force", desc: "+60% move speed", effect: () => { modifiers.moveSpeed += 0.60; } },
                { name: "Enhanced Mobility", desc: "+30% spd, +30% acc, -15% dec", effect: () => { modifiers.moveSpeed += 0.30; modifiers.moveAcceleration += 0.30; modifiers.moveDeceleration -= 0.15; } },
                { name: "Power Sprint", desc: "+45% speed, +25% accel", effect: () => { modifiers.moveSpeed += 0.45; modifiers.moveAcceleration += 0.25; } },
                { name: "Hyperspeed", desc: "+70% move speed", effect: () => { modifiers.moveSpeed += 0.70; } },
                { name: "Sonic Rush", desc: "+80% speed, +40% accel", effect: () => { modifiers.moveSpeed += 0.80; modifiers.moveAcceleration += 0.40; } },
                { name: "Ultimate Agility", desc: "+50% spd, +50% acc, -30% dec", effect: () => { modifiers.moveSpeed += 0.50; modifiers.moveAcceleration += 0.50; modifiers.moveDeceleration -= 0.30; } },
                { name: "Godspeed", desc: "+100% move speed", effect: () => { modifiers.moveSpeed += 1.00; } },
                { name: "Transcendent Velocity", desc: "+150% spd, +75% acc, -50% dec", effect: () => { modifiers.moveSpeed += 1.50; modifiers.moveAcceleration += 0.75; modifiers.moveDeceleration -= 0.50; } }
            ],
            down: [
                { name: "Steady Hands", desc: "-10% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.10; } },
                { name: "Strong Grip", desc: "-20% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.20; } },
                { name: "Firm Hold", desc: "-30% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.30; } },
                { name: "Balanced Carrier", desc: "-40% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.40; } },
                { name: "Expert Handler", desc: "-50% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.50; } },
                { name: "Weight Training", desc: "-60% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.60; } },
                { name: "Pack Mule", desc: "-70% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.70; } },
                { name: "Efficient Hauler", desc: "-80% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.80; } },
                { name: "Zero Burden", desc: "-90% carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction += 0.90; } },
                { name: "Unburdened", desc: "No carry penalty", effect: () => { modifiers.carrySpeedPenaltyReduction = 1.0; } },
                { name: "Overcompensate", desc: "+5% speed when carrying", effect: () => { modifiers.carrySpeedBonus += 0.05; } },
                { name: "Energized Load", desc: "+10% speed when carrying", effect: () => { modifiers.carrySpeedBonus += 0.10; } },
                { name: "Motivated Runner", desc: "+15% speed when carrying", effect: () => { modifiers.carrySpeedBonus += 0.15; } },
                { name: "Power Carrier", desc: "+20% speed when carrying", effect: () => { modifiers.carrySpeedBonus += 0.20; } },
                { name: "Coin Adrenaline", desc: "+25% speed when carrying", effect: () => { modifiers.carrySpeedBonus += 0.25; } },
                { name: "Heavy Motivation", desc: "+30% carry spd, +10% base spd", effect: () => { modifiers.carrySpeedBonus += 0.30; modifiers.moveSpeed += 0.10; } },
                { name: "Treasure Rush", desc: "+35% speed when carrying", effect: () => { modifiers.carrySpeedBonus += 0.35; } },
                { name: "Golden Acceleration", desc: "+20% carry spd, +30% accel", effect: () => { modifiers.carrySpeedBonus += 0.20; modifiers.moveAcceleration += 0.30; } },
                { name: "Cargo Master", desc: "+40% carry spd, +20% base spd", effect: () => { modifiers.carrySpeedBonus += 0.40; modifiers.moveSpeed += 0.20; } },
                { name: "Weight Advantage", desc: "+50% speed when carrying", effect: () => { modifiers.carrySpeedBonus += 0.50; } },
                { name: "Burden Into Power", desc: "+60% carry spd, +15% accel", effect: () => { modifiers.carrySpeedBonus += 0.60; modifiers.moveAcceleration += 0.15; } },
                { name: "Unstoppable Hauler", desc: "+70% carry spd, +25% base spd", effect: () => { modifiers.carrySpeedBonus += 0.70; modifiers.moveSpeed += 0.25; } },
                { name: "Coin Fueled", desc: "+80% carry spd, +30% accel", effect: () => { modifiers.carrySpeedBonus += 0.80; modifiers.moveAcceleration += 0.30; } },
                { name: "Supernatural Carrier", desc: "+100% carry, +40% base spd", effect: () => { modifiers.carrySpeedBonus += 1.00; modifiers.moveSpeed += 0.40; } },
                { name: "Carrying Ascension", desc: "+150% carry, +50% spd, +50% acc", effect: () => { modifiers.carrySpeedBonus += 1.50; modifiers.moveSpeed += 0.50; modifiers.moveAcceleration += 0.50; } }
            ],
            left: [
                { name: "Extra Pocket", desc: "+1 capacity (2 total)", effect: () => { modifiers.carryCapacity += 1; } },
                { name: "Small Pouch", desc: "+1 capacity (3 total)", effect: () => { modifiers.carryCapacity += 1; } },
                { name: "Medium Bag", desc: "+1 capacity (4 total)", effect: () => { modifiers.carryCapacity += 1; } },
                { name: "Large Sack", desc: "+1 capacity (5 total)", effect: () => { modifiers.carryCapacity += 1; } },
                { name: "Backpack", desc: "+2 capacity (7 total)", effect: () => { modifiers.carryCapacity += 2; } },
                { name: "Reinforced Pack", desc: "+2 capacity (9 total)", effect: () => { modifiers.carryCapacity += 2; } },
                { name: "Cargo Harness", desc: "+2 capacity (11 total)", effect: () => { modifiers.carryCapacity += 2; } },
                { name: "Heavy Hauler", desc: "+3 capacity (14 total)", effect: () => { modifiers.carryCapacity += 3; } },
                { name: "Industrial Carrier", desc: "+3 capacity (17 total)", effect: () => { modifiers.carryCapacity += 3; } },
                { name: "Bulk Container", desc: "+3 capacity (20 total)", effect: () => { modifiers.carryCapacity += 3; } },
                { name: "Quick Hands", desc: "+30% pickup range", effect: () => { modifiers.pickupRange += 0.30; } },
                { name: "Magnetic Touch", desc: "+60% pickup range", effect: () => { modifiers.pickupRange += 0.60; } },
                { name: "Coin Magnet", desc: "+100% pickup range", effect: () => { modifiers.pickupRange += 1.00; } },
                { name: "Mass Collector", desc: "+5 cap (25), +20% pickup", effect: () => { modifiers.carryCapacity += 5; modifiers.pickupRange += 0.20; } },
                { name: "Efficient Packer", desc: "+5 capacity (30 total)", effect: () => { modifiers.carryCapacity += 5; } },
                { name: "Treasure Hoarder", desc: "+10 capacity (40 total)", effect: () => { modifiers.carryCapacity += 10; } },
                { name: "Vacuum Collector", desc: "+200% pickup range", effect: () => { modifiers.pickupRange += 2.00; } },
                { name: "Wealth Accumulator", desc: "+10 cap (50), +50% pickup", effect: () => { modifiers.carryCapacity += 10; modifiers.pickupRange += 0.50; } },
                { name: "Coin Stack Master", desc: "+15 capacity (65 total)", effect: () => { modifiers.carryCapacity += 15; } },
                { name: "Portable Vault", desc: "+20 capacity (85 total)", effect: () => { modifiers.carryCapacity += 20; } },
                { name: "Walking Treasury", desc: "+25 cap (110), +100% pickup", effect: () => { modifiers.carryCapacity += 25; modifiers.pickupRange += 1.00; } },
                { name: "Infinite Pockets", desc: "+40 capacity (150 total)", effect: () => { modifiers.carryCapacity += 40; } },
                { name: "Dimensional Storage", desc: "+50 cap (200), +200% pickup", effect: () => { modifiers.carryCapacity += 50; modifiers.pickupRange += 2.00; } },
                { name: "Coin Singularity", desc: "+100 cap (300), +200% pickup", effect: () => { modifiers.carryCapacity += 100; modifiers.pickupRange += 2.00; } },
                { name: "Limitless Vault", desc: "+200 cap (500), +300% pickup", effect: () => { modifiers.carryCapacity += 200; modifiers.pickupRange += 3.00; } }
            ],
            right: [
                { name: "Eagle Eye", desc: "Zoom out by 3%", effect: () => { modifiers.zoomOut += 0.13; } },
                { name: "Wide View", desc: "Zoom out by 6%", effect: () => { modifiers.zoomOut += 0.26; } },
                { name: "Broad Perspective", desc: "Zoom out by 9%", effect: () => { modifiers.zoomOut += 0.39; } },
                { name: "Expanded Vision", desc: "Zoom out by 12%", effect: () => { modifiers.zoomOut += 0.42; } },
                { name: "Panoramic Sight", desc: "Zoom out by 15%", effect: () => { modifiers.zoomOut += 0.45; } },
                { name: "Far Sight", desc: "Zoom out by 20%", effect: () => { modifiers.zoomOut += 0.50; } },
                { name: "Extended Range", desc: "Zoom out by 25%", effect: () => { modifiers.zoomOut += 0.52; } },
                { name: "Distance Viewer", desc: "Zoom out by 30%", effect: () => { modifiers.zoomOut += 0.57; } },
                { name: "Horizon Scanner", desc: "Zoom out by 35%", effect: () => { modifiers.zoomOut += 0.60; } },
                { name: "Long Vision", desc: "Zoom out by 40%", effect: () => { modifiers.zoomOut += 0.40; } },
                { name: "Reduced Sway", desc: "-30% camera offset", effect: () => { modifiers.cameraOffsetReduction += 0.30; } },
                { name: "Stable Camera", desc: "-50% camera offset", effect: () => { modifiers.cameraOffsetReduction += 0.50; } },
                { name: "Steady View", desc: "-70% camera offset", effect: () => { modifiers.cameraOffsetReduction += 0.70; } },
                { name: "Perfect Stability", desc: "No camera offset", effect: () => { modifiers.cameraOffsetReduction = 1.0; } },
                { name: "Ultra Zoom", desc: "Zoom out by 50%", effect: () => { modifiers.zoomOut += 0.50; } },
                { name: "Macro View", desc: "Zoom out by 60%", effect: () => { modifiers.zoomOut += 0.60; } },
                { name: "Bird's Eye", desc: "Zoom out by 70%", effect: () => { modifiers.zoomOut += 0.70; } },
                { name: "Satellite View", desc: "Zoom out by 80%", effect: () => { modifiers.zoomOut += 0.80; } },
                { name: "God's Perspective", desc: "Zoom out by 90%", effect: () => { modifiers.zoomOut += 0.90; } },
                { name: "Coin Radar", desc: "Zoom out 20%, enhanced vision", effect: () => { modifiers.zoomOut += 0.20; } },
                { name: "Omniscient Gaze", desc: "Zoom out by 100%", effect: () => { modifiers.zoomOut += 1.00; } },
                { name: "Perfect Clarity", desc: "Zoom 120%, stable camera", effect: () => { modifiers.zoomOut += 1.20; modifiers.cameraOffsetReduction = 1.0; } },
                { name: "Map Revealer", desc: "Zoom out by 140%", effect: () => { modifiers.zoomOut += 1.40; } },
                { name: "Universal Sight", desc: "Zoom 160%, stable camera", effect: () => { modifiers.zoomOut += 1.60; modifiers.cameraOffsetReduction = 1.0; } },
                { name: "Infinite Vision", desc: "Zoom 200%, perfect control", effect: () => { modifiers.zoomOut += 2.00; modifiers.cameraOffsetReduction = 1.0; } }
            ]
        };

        // Initialize chain segments
        function initChain() {
            chain.segments = [];
            for (let i = 0; i <= chain.links; i++) {
                chain.segments.push({
                    x: post.x,
                    y: post.y + i * 5
                });
            }
        }

        function initPinChain() {
            pinChain.segments = [];
            for (let i = 0; i <= pinChain.links; i++) {
                pinChain.segments.push({
                    x: pinPost.x,
                    y: pinPost.y + i * 5
                });
            }
        }

        function initBrotChain() {
            brotChain.segments = [];
            for (let i = 0; i <= brotChain.links; i++) {
                brotChain.segments.push({
                    x: brotPost.x,
                    y: brotPost.y + i * 5
                });
            }
        }

        // Coins
        const coins = [];

        // Dropped items on ground
        const droppedItems = [];

        // Packages (for courier job)
        const packages = [];

        // Farm animals (triangles for sorting job)
        const farmAnimals = [];

        // Barriers (walls for mazes)
        const barriers = [
/*            {
                x: 0,
                y: 500,
                width: 300,
                height: 300
            }*/
        ];

        // Visual elements - purely decorative
        // Grass patches (lines that rotate when player is near)
        const grassPatches = [];

        // Puddles (create ripples when player enters)
        const puddles = [];
        const ripples = []; // Active ripple animations

        // Footprints (fade over time)
        const footprints = [];
        const FOOTPRINT_INTERVAL = 15; // Frames between footprints
        let footprintTimer = 0;

        // Dust particles (drift when player moves)
        const dustParticles = [];

        // Track if player has dropped coins (for Straum's dialogue)
        let playerDroppedCoins = false;

        // Track all collected music disks and current selection
        let collectedDisks = []; // Array of { name: string, trackPaths: array }
        let currentDiskIndex = -1; // -1 means silence, 0+ is disk index

        // Reset save timer
        let resetHoldTimer = 0;
        const RESET_HOLD_DURATION = 3.0; // 3 seconds

        // Disk switching timer
        let diskSwitchHoldTimer = 0;
        const DISK_SWITCH_HOLD_DURATION = 0.5; // 500ms
        let diskSwitchTriggered = false;

        // Save game state to localStorage
        function saveGame() {
            const saveData = {
                playerX: player.x,
                playerY: player.y,
                chainLinks: chain.links,
                chainSegments: chain.segments,
                coinsDeposited: game.coinsDeposited,
                hasHomeBeacon: game.hasHomeBeacon,
                hasWorkTools: game.hasWorkTools,
                hasMaxFulfillmentCoin: game.hasMaxFulfillmentCoin,
                hasAirOfConfidence: game.hasAirOfConfidence,
                npcs: npcs.map(npc => ({
                    name: npc.name,
                    itemGiven: npc.itemGiven,
                    hasCompletedQuest: npc.hasCompletedQuest,
                    coinsCollected: npc.coinsCollected || 0,
                    isCollecting: npc.isCollecting || false,
                    coinsInventory: npc.coinsInventory,
                    diamondGiven: npc.diamondGiven,
                    workToolsGiven: npc.workToolsGiven || false,
                    needsWorkTools: npc.needsWorkTools || false,
                    jobAccepted: npc.jobAccepted || false,
                    firstRetrievalCompleted: npc.firstRetrievalCompleted || false,
                    allAnimalsRetrieved: npc.allAnimalsRetrieved || false,
                    firstDeliveryMade: npc.firstDeliveryMade || false,
                    // Clint follower state
                    isFollowing: npc.isFollowing || false,
                    followSide: npc.followSide || 0,
                    // Ram diamond collecting state
                    isCollectingDiamond: npc.isCollectingDiamond || false,
                    x: npc.x,
                    y: npc.y
                })),
                jobs: {
                    hasCourier: jobs.hasCourier,
                    hasSorter: jobs.hasSorter,
                    courierDeliveriesToday: jobs.courierDeliveriesToday,
                    courierLastResetDate: jobs.courierLastResetDate,
                    sorterLastResetDate: jobs.sorterLastResetDate,
                    sortedToday: jobs.sortedToday,
                    retrievedToday: jobs.retrievedToday
                },
                modifiers: { ...modifiers },
                carryingItems: player.carryingItems,
                carryingCoins: player.carryingCoins,
                droppedItems: droppedItems.map(item => ({
                    x: item.x,
                    y: item.y,
                    collected: item.collected,
                    item: item.item
                })),
                collectedDisks: collectedDisks,
                currentDiskIndex: currentDiskIndex,
                coins: coins.map(coin => ({
                    x: coin.x,
                    y: coin.y,
                    collected: coin.collected
                })),
                playerDroppedCoins: playerDroppedCoins,
                barriers: barriers,
                farmAnimals: farmAnimals.map(animal => ({
                    x: animal.x,
                    y: animal.y,
                    radius: animal.radius,
                    color: animal.color,
                    outlineColor: animal.outlineColor,
                    following: animal.following || false,
                    targetX: animal.targetX || 0,
                    targetY: animal.targetY || 0
                })),
                pinChainLinks: pinChain.links,
                pinChainSegments: pinChain.segments,
                pinX: npcs.find(n => n.name === 'Pin')?.x || 3033,
                pinY: npcs.find(n => n.name === 'Pin')?.y || -49,
                // Brot state
                brotChainLinks: brotChain.links,
                brotChainSegments: brotChain.segments,
                brotX: npcs.find(n => n.name === 'Brot')?.x || -4600,
                brotY: npcs.find(n => n.name === 'Brot')?.y || 3400,
                brotAnimalsCollected: npcs.find(n => n.name === 'Brot')?.animalsCollected || 0,
                brotAnimals: brotAnimals.map(animal => ({
                    x: animal.x,
                    y: animal.y,
                    radius: animal.radius,
                    color: animal.color,
                    outlineColor: animal.outlineColor,
                    inBrotZone: true,
                    brotBehaviorState: animal.brotBehaviorState || 'idle',
                    brotIdleTimer: animal.brotIdleTimer || 300,
                    brotTargetX: animal.brotTargetX || animal.x,
                    brotTargetY: animal.brotTargetY || animal.y
                }))
            };

            localStorage.setItem('chainGameSave', JSON.stringify(saveData));
        }

        // Load game state from localStorage
        function loadGame() {
            const saveDataStr = localStorage.getItem('chainGameSave');
            if (!saveDataStr) return false;

            try {
                const saveData = JSON.parse(saveDataStr);

                // Restore player position
                player.x = saveData.playerX;
                player.y = saveData.playerY;

                // Restore chain
                chain.links = saveData.chainLinks;
                chain.segments = saveData.chainSegments || [];

                // Ensure segments array has correct length (links + 1)
                while (chain.segments.length < chain.links + 1) {
                    chain.segments.push({ x: post.x, y: post.y });
                }
                while (chain.segments.length > chain.links + 1) {
                    chain.segments.pop();
                }

                // Restore coins deposited
                game.coinsDeposited = saveData.coinsDeposited;

                // Restore home beacon, work tools, max fulfillment coin, and air of confidence
                game.hasHomeBeacon = saveData.hasHomeBeacon || false;
                game.hasWorkTools = saveData.hasWorkTools || false;
                game.hasMaxFulfillmentCoin = saveData.hasMaxFulfillmentCoin || false;
                game.hasAirOfConfidence = saveData.hasAirOfConfidence || false;

                // Restore NPC states
                saveData.npcs.forEach(savedNpc => {
                    const npc = npcs.find(n => n.name === savedNpc.name);
                    if (npc) {
                        npc.itemGiven = savedNpc.itemGiven;
                        npc.hasCompletedQuest = savedNpc.hasCompletedQuest;
                        npc.coinsCollected = savedNpc.coinsCollected;
                        npc.isCollecting = savedNpc.isCollecting;
                        if (savedNpc.coinsInventory !== undefined) {
                            npc.coinsInventory = savedNpc.coinsInventory;
                        }
                        if (savedNpc.diamondGiven !== undefined) {
                            npc.diamondGiven = savedNpc.diamondGiven;
                        }
                        if (savedNpc.workToolsGiven !== undefined) {
                            npc.workToolsGiven = savedNpc.workToolsGiven;
                        }
                        if (savedNpc.needsWorkTools !== undefined) {
                            npc.needsWorkTools = savedNpc.needsWorkTools;
                        }
                        if (savedNpc.jobAccepted !== undefined) {
                            npc.jobAccepted = savedNpc.jobAccepted;
                        }
                        if (savedNpc.firstRetrievalCompleted !== undefined) {
                            npc.firstRetrievalCompleted = savedNpc.firstRetrievalCompleted;
                        }
                        if (savedNpc.allAnimalsRetrieved !== undefined) {
                            npc.allAnimalsRetrieved = savedNpc.allAnimalsRetrieved;
                        }
                        if (savedNpc.firstDeliveryMade !== undefined) {
                            npc.firstDeliveryMade = savedNpc.firstDeliveryMade;
                        }
                        // Restore Clint's follower state
                        if (savedNpc.isFollowing !== undefined) {
                            npc.isFollowing = savedNpc.isFollowing;
                        }
                        if (savedNpc.followSide !== undefined) {
                            npc.followSide = savedNpc.followSide;
                        }
                        // Restore Ram's diamond collecting state
                        if (savedNpc.isCollectingDiamond !== undefined) {
                            npc.isCollectingDiamond = savedNpc.isCollectingDiamond;
                        }
                        if (savedNpc.x !== undefined) {
                            npc.x = savedNpc.x;
                        }
                        if (savedNpc.y !== undefined) {
                            npc.y = savedNpc.y;
                        }
                    }
                });

                // Restore modifiers
                Object.assign(modifiers, saveData.modifiers);

                // Restore carrying items (need to restore effect functions for abilities)
                player.carryingItems = (saveData.carryingItems || []).map(item => {
                    if (item.type === 'ability') {
                        // First check skills database
                        for (let direction in skills) {
                            const skill = skills[direction].find(s => s.name === item.name);
                            if (skill) {
                                return {
                                    ...item,
                                    effect: skill.effect
                                };
                            }
                        }

                        // If not found in skills, check NPCs (for NPC-specific abilities)
                        const npcWithAbility = npcs.find(n => n.abilityName === item.name);
                        if (npcWithAbility && npcWithAbility.abilityEffect) {
                            return {
                                ...item,
                                effect: npcWithAbility.abilityEffect
                            };
                        }
                    }
                    return item;
                });
                player.carryingCoins = saveData.carryingCoins || [];

                // Restore dropped items (need to restore effect functions for abilities)
                droppedItems.length = 0;
                saveData.droppedItems.forEach(item => {
                    let restoredItem = item.item;

                    // Restore effect function for ability items
                    if (restoredItem.type === 'ability') {
                        // First check skills database
                        for (let direction in skills) {
                            const skill = skills[direction].find(s => s.name === restoredItem.name);
                            if (skill) {
                                restoredItem = {
                                    ...restoredItem,
                                    effect: skill.effect
                                };
                                break;
                            }
                        }

                        // If not found in skills, check NPCs (for NPC-specific abilities)
                        if (!restoredItem.effect) {
                            const npcWithAbility = npcs.find(n => n.abilityName === restoredItem.name);
                            if (npcWithAbility && npcWithAbility.abilityEffect) {
                                restoredItem = {
                                    ...restoredItem,
                                    effect: npcWithAbility.abilityEffect
                                };
                            }
                        }
                    }

                    droppedItems.push({
                        x: item.x,
                        y: item.y,
                        radius: 8,
                        color: '#000',
                        outlineColor: '#fff',
                        collected: item.collected,
                        item: restoredItem
                    });
                });

                // Restore coins
                coins.length = 0;
                saveData.coins.forEach(coin => {
                    coins.push({
                        x: coin.x,
                        y: coin.y,
                        radius: 8,
                        color: '#fff',
                        collected: coin.collected
                    });
                });

                // Restore collected disks and current selection
                collectedDisks = saveData.collectedDisks || [];
                currentDiskIndex = saveData.currentDiskIndex !== undefined ? saveData.currentDiskIndex : -1;

                // Remove any existing music at post
                for (let i = musicPoints.length - 1; i >= 0; i--) {
                    if (musicPoints[i].x === post.x && musicPoints[i].y === post.y) {
                        musicPoints[i].audioTracks.forEach(audio => audio.pause());
                        musicPoints.splice(i, 1);
                    }
                }

                // If a disk is selected (not silence), add it to the post
                if (currentDiskIndex >= 0 && currentDiskIndex < collectedDisks.length) {
                    const disk = collectedDisks[currentDiskIndex];
                    addMusicPoint(post.x, post.y, disk.trackPaths, 3000, disk.name);
                }

                // If George gave his disk, remove his music point
                const george = npcs.find(n => n.name === 'George');
                if (george && george.itemGiven && georgeMusicPoint) {
                    georgeMusicPoint.audioTracks.forEach(audio => audio.pause());
                    const index = musicPoints.indexOf(georgeMusicPoint);
                    if (index > -1) {
                        musicPoints.splice(index, 1);
                    }
                    georgeMusicPoint = null;
                }

                // If Klaus gave his disk, remove his music point
                const klaus = npcs.find(n => n.name === 'Klaus');
                if (klaus && klaus.itemGiven && klausMusicPoint) {
                    klausMusicPoint.audioTracks.forEach(audio => audio.pause());
                    const index = musicPoints.indexOf(klausMusicPoint);
                    if (index > -1) {
                        musicPoints.splice(index, 1);
                    }
                    klausMusicPoint = null;
                }

                // If Noodles gave his disk, remove his music point
                const noodles = npcs.find(n => n.name === 'Noodles');
                if (noodles && noodles.itemGiven && noodlesMusicPoint) {
                    noodlesMusicPoint.audioTracks.forEach(audio => audio.pause());
                    const index = musicPoints.indexOf(noodlesMusicPoint);
                    if (index > -1) {
                        musicPoints.splice(index, 1);
                    }
                    noodlesMusicPoint = null;
                }

                // Restore playerDroppedCoins flag
                playerDroppedCoins = saveData.playerDroppedCoins || false;

                // Restore barriers
                if (saveData.barriers) {
                    barriers.length = 0;
                    saveData.barriers.forEach(barrier => {
                        barriers.push({
                            x: barrier.x,
                            y: barrier.y,
                            width: barrier.width,
                            height: barrier.height
                        });
                    });
                }

                // Restore jobs state
                if (saveData.jobs) {
                    jobs.hasCourier = saveData.jobs.hasCourier || false;
                    jobs.hasSorter = saveData.jobs.hasSorter || false;
                    jobs.courierDeliveriesToday = saveData.jobs.courierDeliveriesToday || 0;
                    jobs.courierLastResetDate = saveData.jobs.courierLastResetDate || null;
                    jobs.sorterLastResetDate = saveData.jobs.sorterLastResetDate || null;
                    jobs.sortedToday = saveData.jobs.sortedToday || false;
                    jobs.retrievedToday = saveData.jobs.retrievedToday || false;
                }

                // Restore farm animals
                if (saveData.farmAnimals) {
                    farmAnimals.length = 0;
                    saveData.farmAnimals.forEach(animal => {
                        farmAnimals.push({
                            x: animal.x,
                            y: animal.y,
                            radius: animal.radius,
                            color: animal.color,
                            outlineColor: animal.outlineColor,
                            following: animal.following || false,
                            targetX: animal.targetX || 0,
                            targetY: animal.targetY || 0
                        });
                    });
                }

                // Restore Pin's chain and position
                if (saveData.pinChainLinks !== undefined) {
                    pinChain.links = saveData.pinChainLinks;
                    pinChain.segments = saveData.pinChainSegments || [];

                    // Ensure segments array has correct length (links + 1)
                    while (pinChain.segments.length < pinChain.links + 1) {
                        pinChain.segments.push({ x: pinPost.x, y: pinPost.y });
                    }
                    while (pinChain.segments.length > pinChain.links + 1) {
                        pinChain.segments.pop();
                    }

                    // Restore Pin's position
                    const pin = npcs.find(n => n.name === 'Pin');
                    if (pin && saveData.pinX !== undefined && saveData.pinY !== undefined) {
                        pin.x = saveData.pinX;
                        pin.y = saveData.pinY;
                    }
                }

                // Restore Brot's state
                if (saveData.brotChainLinks !== undefined) {
                    brotChain.links = saveData.brotChainLinks;
                    brotChain.segments = saveData.brotChainSegments || [];

                    // Ensure segments array has correct length (links + 1)
                    while (brotChain.segments.length < brotChain.links + 1) {
                        brotChain.segments.push({ x: brotPost.x, y: brotPost.y });
                    }
                    while (brotChain.segments.length > brotChain.links + 1) {
                        brotChain.segments.pop();
                    }

                    // Restore Brot's position
                    const brot = npcs.find(n => n.name === 'Brot');
                    if (brot && saveData.brotX !== undefined && saveData.brotY !== undefined) {
                        brot.x = saveData.brotX;
                        brot.y = saveData.brotY;
                    }

                    // Restore Brot's animals collected count
                    if (brot && saveData.brotAnimalsCollected !== undefined) {
                        brot.animalsCollected = saveData.brotAnimalsCollected;
                    }
                }

                // Restore Brot's animals
                if (saveData.brotAnimals) {
                    brotAnimals.length = 0;
                    saveData.brotAnimals.forEach(animal => {
                        brotAnimals.push({
                            x: animal.x,
                            y: animal.y,
                            radius: animal.radius || 8,
                            color: animal.color || '#000',
                            outlineColor: animal.outlineColor || '#fff',
                            inBrotZone: true,
                            brotBehaviorState: animal.brotBehaviorState || 'idle',
                            brotIdleTimer: animal.brotIdleTimer || 300,
                            brotTargetX: animal.brotTargetX || animal.x,
                            brotTargetY: animal.brotTargetY || animal.y
                        });
                    });
                }

                return true;
            } catch (e) {
                console.error('Failed to load save:', e);
                return false;
            }
        }

        function spawnCoin(minDist, maxDist) {
            // Try up to 50 times to find a position not in a barrier
            for (let attempt = 0; attempt < 50; attempt++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = minDist + Math.random() * (maxDist - minDist);
                const x = Math.cos(angle) * dist;
                const y = Math.sin(angle) * dist;

                // Check if this position overlaps with any barrier
                let overlapsBarrier = false;
                for (let barrier of barriers) {
                    const closestX = Math.max(barrier.x, Math.min(x, barrier.x + barrier.width));
                    const closestY = Math.max(barrier.y, Math.min(y, barrier.y + barrier.height));
                    const distX = x - closestX;
                    const distY = y - closestY;
                    const distSquared = distX * distX + distY * distY;
                    const coinRadius = 8;

                    if (distSquared < coinRadius * coinRadius) {
                        overlapsBarrier = true;
                        break;
                    }
                }

                if (!overlapsBarrier) {
                    return {
                        x: x,
                        y: y,
                        radius: 8,
                        color: '#fff',
                        collected: false
                    };
                }
            }

            // If we couldn't find a valid position after 50 tries, just return something far away
            return {
                x: 5000,
                y: 5000,
                radius: 8,
                color: '#fff',
                collected: false
            };
        }

        function initCoins() {
            // Always spawn one coin within current range
            const maxReach = chain.links * chain.linkLength;
            coins.push(spawnCoin(maxReach * 0.7, maxReach * 0.95));

            // Spawn many random coins at various distances
            for (let i = 0; i < 200; i++) {
                coins.push(spawnCoin(100, 2500));
            }
        }

        function ensureReachableCoin() {
            // Check if there's at least one uncollected coin within reach
            const maxReach = chain.links * chain.linkLength;
            let hasReachable = false;

            for (let coin of coins) {
                if (coin.collected) continue;
                const dist = Math.sqrt(coin.x * coin.x + coin.y * coin.y);
                if (dist <= maxReach * 0.95) {
                    hasReachable = true;
                    break;
                }
            }

            // If no reachable coin exists, spawn one
            if (!hasReachable) {
                coins.push(spawnCoin(maxReach * 0.7, maxReach * 0.95));
            }
        }

        // Initialize visual elements (grass, puddles)
        function initVisualElements() {
            // Grass patches near NPCs - each patch has multiple grass blades
            const grassLocations = [
                { x: 150, y: 150, count: 12 },      // Tim
                { x: -150, y: 200, count: 8 },     // Gary
                { x: 350, y: 250, count: 10 },     // Chris
                { x: 400, y: 350, count: 8 },      // Bob
                { x: -500, y: 500, count: 15 },    // Zoe
                { x: -600, y: -350, count: 10 },   // Ron
                { x: 550, y: -200, count: 12 },    // Eddie
                { x: 0, y: -1000, count: 20 },     // George
                { x: 2000, y: 100, count: 15 },    // Fritz
                { x: -2000, y: -600, count: 18 },  // Jawn
                { x: 3033, y: -49, count: 25 },    // Pin
            ];

            // Dense grass patch for Brot's 800px animal zone
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 100 + Math.random() * 700; // Spread across 800px radius
                grassPatches.push({
                    x: -4600 + Math.cos(angle) * dist,
                    y: 3400 + Math.sin(angle) * dist,
                    baseAngle: -Math.PI / 2 + (Math.random() - 0.5) * 0.3,
                    currentAngle: -Math.PI / 2,
                    bentAngle: -Math.PI / 2,
                    length: 4 + Math.random() * 5,
                    swayOffset: Math.random() * Math.PI * 2,
                    bentTimer: 0
                });
            }

            // Large grass patch for Ram
            for (let i = 0; i < 80; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 150; // Spread across ~150px radius
                grassPatches.push({
                    x: -1474 + Math.cos(angle) * dist,
                    y: 1819 + Math.sin(angle) * dist,
                    baseAngle: -Math.PI / 2 + (Math.random() - 0.5) * 0.3,
                    currentAngle: -Math.PI / 2,
                    bentAngle: -Math.PI / 2,
                    length: 4 + Math.random() * 5,
                    swayOffset: Math.random() * Math.PI * 2,
                    bentTimer: 0
                });
            }

            for (let loc of grassLocations) {
                for (let i = 0; i < loc.count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 20 + Math.random() * 60;
                    grassPatches.push({
                        x: loc.x + Math.cos(angle) * dist,
                        y: loc.y + Math.sin(angle) * dist,
                        baseAngle: -Math.PI / 2 + (Math.random() - 0.5) * 0.3, // Mostly upward
                        currentAngle: -Math.PI / 2,
                        bentAngle: -Math.PI / 2, // Angle when bent
                        length: 4 + Math.random() * 5,
                        swayOffset: Math.random() * Math.PI * 2, // For gentle sway
                        bentTimer: 0 // Frames since last bent (0 = not bent)
                    });
                }
            }

            // Puddles in remote/water areas
            const puddleLocations = [
                { x: 3500, y: 3200, count: 5 },    // Near Moe
                { x: -3800, y: -3400, count: 4 }, // Near Don
                { x: -3200, y: 3800, count: 6 },  // Near Rob
                { x: 4500, y: -60, count: 3 },    // Near Klaus
                { x: 1000, y: 1000, count: 4 },   // Near Straum
                { x: -1500, y: -1500, count: 5 }, // Remote area
                { x: 2500, y: -1500, count: 4 },  // Remote area
                { x: -2500, y: 1500, count: 5 },  // Remote area
            ];

            for (let loc of puddleLocations) {
                for (let i = 0; i < loc.count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 30 + Math.random() * 100;
                    puddles.push({
                        x: loc.x + Math.cos(angle) * dist,
                        y: loc.y + Math.sin(angle) * dist,
                        radius: 80 + Math.random() * 70,
                        playerInside: false
                    });
                }
            }
        }

        // Update visual elements
        function updateVisualElements() {
            const playerSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            const isMoving = playerSpeed > 0.1;

            // Update grass - rotate toward player movement and chain
            const BENT_HOLD_FRAMES = 180; // 3 seconds at 60fps
            for (let grass of grassPatches) {
                // Gentle ambient sway
                grass.swayOffset += 0.02;
                const sway = Math.sin(grass.swayOffset) * 0.05;

                // Check player influence
                const dxPlayer = player.x - grass.x;
                const dyPlayer = player.y - grass.y;
                const distPlayer = Math.sqrt(dxPlayer * dxPlayer + dyPlayer * dyPlayer);

                let bestInfluence = 0;
                let bestPushAngle = 0;

                if (distPlayer < 30 && isMoving) {
                    bestInfluence = (1 - distPlayer / 30) * 0.8;
                    bestPushAngle = Math.atan2(player.vy, player.vx);
                }

                // Check chain segment influence (sample every few segments for performance)
                const sampleStep = Math.max(1, Math.floor(chain.segments.length / 50));
                for (let i = 0; i < chain.segments.length; i += sampleStep) {
                    const seg = chain.segments[i];
                    const dxSeg = seg.x - grass.x;
                    const dySeg = seg.y - grass.y;
                    const distSeg = Math.sqrt(dxSeg * dxSeg + dySeg * dySeg);

                    if (distSeg < 20) {
                        const segInfluence = (1 - distSeg / 20) * 0.6;
                        if (segInfluence > bestInfluence) {
                            bestInfluence = segInfluence;
                            // Push away from chain segment
                            bestPushAngle = Math.atan2(-dySeg, -dxSeg);
                        }
                    }
                }

                if (bestInfluence > 0) {
                    // Being bent - store the bent angle and reset timer
                    grass.bentAngle = grass.baseAngle + bestPushAngle * bestInfluence + Math.PI * bestInfluence * 0.3;
                    grass.bentTimer = BENT_HOLD_FRAMES;
                    grass.currentAngle = grass.bentAngle + sway;
                } else if (grass.bentTimer > 0) {
                    // Hold bent position, then slowly return
                    grass.bentTimer--;
                    if (grass.bentTimer > 0) {
                        // Still holding - stay bent with sway
                        grass.currentAngle = grass.bentAngle + sway;
                    } else {
                        // Start returning
                        grass.currentAngle += (grass.baseAngle + sway - grass.currentAngle) * 0.03;
                    }
                } else {
                    // Return to base angle with sway
                    grass.currentAngle += (grass.baseAngle + sway - grass.currentAngle) * 0.03;
                }
            }

            // Update puddles - check for player entry
            for (let puddle of puddles) {
                const dx = player.x - puddle.x;
                const dy = player.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const wasInside = puddle.playerInside;
                puddle.playerInside = dist < puddle.radius;

                // Create small ripples while player is inside and moving
                if (puddle.playerInside && isMoving && Math.random() < 0.08) {
                    ripples.push({
                        x: player.x + (Math.random() - 0.5) * 10,
                        y: player.y + (Math.random() - 0.5) * 10,
                        progress: 0,
                        maxRadius: 25 + Math.random() * 20,
                        alpha: 0.5,
                        duration: 120 + Math.random() * 60 // frames to complete
                    });
                }
            }

            // Update ripples with easeout
            for (let i = ripples.length - 1; i >= 0; i--) {
                const ripple = ripples[i];
                ripple.progress += 1 / ripple.duration;

                // Easeout: starts fast, slows down
                const easeOut = 1 - Math.pow(1 - ripple.progress, 3);
                ripple.radius = easeOut * ripple.maxRadius;
                ripple.alpha = 0.5 * (1 - ripple.progress);

                if (ripple.progress >= 1) {
                    ripples.splice(i, 1);
                }
            }

            // Update footprints (disabled)
            /*
            if (isMoving) {
                footprintTimer++;
                if (footprintTimer >= FOOTPRINT_INTERVAL) {
                    footprintTimer = 0;
                    footprints.push({
                        x: player.x,
                        y: player.y,
                        alpha: 0.3,
                        angle: Math.atan2(player.vy, player.vx)
                    });
                }
            }

            // Fade footprints
            for (let i = footprints.length - 1; i >= 0; i--) {
                footprints[i].alpha -= 0.003;
                if (footprints[i].alpha <= 0) {
                    footprints.splice(i, 1);
                }
            }
            */

            // Spawn dust particles when moving
            if (isMoving && Math.random() < 0.15) {
                dustParticles.push({
                    x: player.x + (Math.random() - 0.5) * 10,
                    y: player.y + (Math.random() - 0.5) * 10,
                    vx: -player.vx * 0.1 + (Math.random() - 0.5) * 0.5,
                    vy: -player.vy * 0.1 + (Math.random() - 0.5) * 0.5,
                    alpha: 0.25,
                    size: 1 + Math.random() * 2
                });
            }

            // Update dust particles
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                const dust = dustParticles[i];
                dust.x += dust.vx;
                dust.y += dust.vy;
                dust.vx *= 0.98;
                dust.vy *= 0.98;
                dust.alpha -= 0.008;

                if (dust.alpha <= 0) {
                    dustParticles.splice(i, 1);
                }
            }
        }

        // George's music point reference
        let georgeMusicPoint = null;

        // Klaus's music point reference
        let klausMusicPoint = null;

        // Noodles's music point reference
        let noodlesMusicPoint = null;

        // Initialize music points
        function initMusic() {
            // Add George's music point at his location with 1000 range
            georgeMusicPoint = addMusicPoint(0, -1000, ['music/Chill Tune Disk/chilltune.wav'], 1000, 'Chill Tune Disk');

            // Add Klaus's music point at his location with 1000 range
            klausMusicPoint = addMusicPoint(4500, -60, [
                'music/CacheFull/Angelic.wav',
                'music/CacheFull/Disk.wav',
                'music/CacheFull/Moonlit.wav',
                'music/CacheFull/Panther.wav',
                'music/CacheFull/Sum err.wav',
                'music/CacheFull/blu icee.wav',
                'music/CacheFull/dicsker.wav',
                'music/CacheFull/downbound.wav',
                'music/CacheFull/wet n deep.wav'
            ], 2000, 'Cache Full Disk');

            // Add Noodles's music point at his location with 3000 range
            noodlesMusicPoint = addMusicPoint(-4500, -4060, [
                'music/BUDSbeats/1 - buds intro.wav',
                'music/BUDSbeats/2 - animace face (401k).wav',
                'music/BUDSbeats/3 - animace face (soul).wav',
                'music/BUDSbeats/4- DAWG WALKER  (light idea).wav',
                'music/BUDSbeats/5 -  SUNSET SHERBERT (matrix).wav',
                'music/BUDSbeats/7 - GSC  (morning groove).wav',
                'music/BUDSbeats/8 - GG#4 (french joint).wav',
                'music/BUDSbeats/9 - JET FUEL GELATO  (on 1).wav',
                'music/BUDSbeats/10- WEDDING CAKE (stbg).wav',
                'music/BUDSbeats/12 - MOON ROCKS  (owe u nothin).wav',
                'music/BUDSbeats/13 - HANS SOLO BURGER (woohoo!).wav',
                'music/BUDSbeats/14 - Buds Outro.wav'
            ], 3000, 'BUDSbeats');
        }

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            // Fullscreen toggle
            if (e.key === 'f' || e.key === 'F') {
                if (!document.fullscreenElement) {
                    canvas.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
                return;
            }

            // Debug: Toggle work tools (key 9)
            if (e.key === '9') {
                game.hasWorkTools = !game.hasWorkTools;
                console.log('Work tools:', game.hasWorkTools);
                return;
            }

            // Debug: Add 10 links to chain (key L)
            if (e.key === 'l' || e.key === 'L') {
                for (let i = 0; i < 10; i++) {
                    chain.links++;
                    chain.segments.push({ x: player.x, y: player.y });
                }
                game.coinsDeposited += 10;
                console.log('Added 10 links. Total links:', chain.links);
                saveGame();
                return;
            }

            // Debug: Remove 10 links from chain (key K)
            if (e.key === 'k' || e.key === 'K') {
                const linksToRemove = Math.min(10, chain.links);
                chain.links -= linksToRemove;
                for (let i = 0; i < linksToRemove; i++) {
                    if (chain.segments.length > 0) {
                        chain.segments.pop();
                    }
                }
                game.coinsDeposited = Math.max(0, game.coinsDeposited - linksToRemove);
                console.log('Removed', linksToRemove, 'links. Total links:', chain.links);
                saveGame();
                return;
            }

            // Debug: Display all collected items (key I)
            if (e.key === 'i' || e.key === 'I') {
                console.log('=== COLLECTED ITEMS ===');
                console.log('Chain links:', chain.links);
                console.log('Coins deposited:', game.coinsDeposited);
                console.log('Has Home Beacon:', game.hasHomeBeacon);
                console.log('Has Work Tools:', game.hasWorkTools);
                console.log('Has Max Fulfillment Coin:', game.hasMaxFulfillmentCoin);
                console.log('Has Air of Confidence:', game.hasAirOfConfidence);
                console.log('--- Collected Disks ---');
                if (collectedDisks.length === 0) {
                    console.log('  (none)');
                } else {
                    collectedDisks.forEach((disk, i) => {
                        console.log(`  ${i + 1}. ${disk.name} (${disk.trackPaths.length} tracks)`);
                    });
                }
                console.log('Current disk index:', currentDiskIndex, currentDiskIndex >= 0 && currentDiskIndex < collectedDisks.length ? `(${collectedDisks[currentDiskIndex].name})` : '(silence)');
                console.log('--- Carrying Items ---');
                if (player.carryingItems.length === 0) {
                    console.log('  (none)');
                } else {
                    player.carryingItems.forEach((item, i) => {
                        console.log(`  ${i + 1}. ${item.type}: ${item.name || item.type}`);
                    });
                }
                console.log('Carrying coins:', player.carryingCoins.length);
                console.log('======================');
                return;
            }

            // Debug: Increase speed (key +)
            if (e.key === '+' || e.key === '=') {
                modifiers.moveSpeed += 0.1;
                console.log('Speed increased. Current speed modifier:', modifiers.moveSpeed.toFixed(2));
                return;
            }

            // Debug: Decrease speed (key -)
            if (e.key === '-' || e.key === '_') {
                modifiers.moveSpeed -= 0.1;
                console.log('Speed decreased. Current speed modifier:', modifiers.moveSpeed.toFixed(2));
                return;
            }

            // Debug: Reset job NPCs (key 0)
            if (e.key === '0') {
                const wheaton = npcs.find(n => n.name === 'Wheaton');
                const weadon = npcs.find(n => n.name === 'Weadon');
                const tim = npcs.find(n => n.name === 'Tim');

                if (wheaton) {
                    wheaton.jobAccepted = false;
                    wheaton.firstRetrievalCompleted = false;
                    wheaton.allAnimalsRetrieved = false;
                }
                if (weadon) {
                    weadon.jobAccepted = false;
                    weadon.firstDeliveryMade = false;
                }
                if (tim) {
                    tim.needsWorkTools = false;
                    tim.workToolsGiven = false;
                }

                jobs.hasCourier = false;
                jobs.hasSorter = false;
                jobs.currentPackage = null;
                jobs.packageDeadline = null;

                console.log('Reset all job NPCs');
                saveGame();
                return;
            }

            // Ability display countdown skip
            if (game.showAbilityDisplay && game.abilityDisplayTimer < game.abilityDisplayDelay && e.key in game.keysPressed && !game.keysPressed[e.key]) {
                game.keysPressed[e.key] = true;
                game.abilityDisplayTimer += 1.0;
                return;
            }

            // Dialogue controls
            if (dialogue.active && !dialogue.isWaiting && e.key in game.keysPressed && !game.keysPressed[e.key]) {
                game.keysPressed[e.key] = true;

                // Handle yes/no choices
                if (dialogue.pendingChoice) {
                    if (e.key === 'ArrowUp') {
                        dialogue.choiceResult = 'yes';
                        dialogue.pendingChoice = false;
                        advanceDialogue(); // Automatically advance after making choice
                    } else if (e.key === 'ArrowDown') {
                        dialogue.choiceResult = 'no';
                        dialogue.pendingChoice = false;
                        advanceDialogue(); // Automatically advance after making choice
                    }
                    return;
                }

                // Navigate dialogue pages
                if (e.key === 'ArrowRight') {
                    advanceDialogue();
                } else if (e.key === 'ArrowLeft') {
                    previousDialogue();
                }
                return;
            }

            // Normal movement keys
            if (e.key in game.keys) {
                game.keys[e.key] = true;
                // Mark that user has interacted (for Chrome autoplay policy)
                if (e.key.startsWith('Arrow')) {
                    game.userHasInteracted = true;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in game.keys) {
                game.keys[e.key] = false;
            }
            if (e.key in game.keysPressed) {
                game.keysPressed[e.key] = false;
            }
        });

        // Dialogue functions
        function startDialogue(npc) {
            // Clint won't talk while following
            if (npc.name === 'Clint' && npc.isFollowing) {
                return;
            }

            dialogue.active = true;
            dialogue.npc = npc;
            dialogue.currentPage = 0;
            dialogue.waitTimer = 0;
            dialogue.isWaiting = true;
            dialogue.pendingChoice = false;
            dialogue.choiceResult = null;
            dialogue.showingNeedsWorkTools = false; // Reset needs work tools flag
            game.paused = true;

            // Straum special handling
            if (npc.itemType === 'straum') {
                dialogue.showingDeclinedDialogue = false;
                dialogue.showingStraumDiamondDeclined = false;
                // Check if we should show dropped coins dialogue
                if (playerDroppedCoins && npc.coinsInventory > 0) {
                    dialogue.showingStraumDropped = true;
                    dialogue.showingStraumDiamond = false;
                } else if (npc.coinsInventory === 0 && !npc.diamondGiven) {
                    // Show diamond offer dialogue
                    dialogue.showingStraumDropped = false;
                    dialogue.showingStraumDiamond = true;
                    // Diamond offer is single-page with choice - set pendingChoice immediately
                    dialogue.pendingChoice = true;
                } else if (npc.coinsInventory > 0) {
                    // Coin offer dialogue
                    dialogue.showingStraumDropped = false;
                    dialogue.showingStraumDiamond = false;
                } else {
                    dialogue.showingStraumDropped = false;
                    dialogue.showingStraumDiamond = false;
                }
            }
        }

        function advanceDialogue() {
            if (!dialogue.npc) return;

            const npc = dialogue.npc;
            let pages = npc.dialogue;
            const totalCarrying = player.carryingCoins.length + player.carryingItems.length;

            // First, determine which dialogue we're CURRENTLY showing (before any transitions)
            let currentPages = npc.dialogue;

            // Straum special dialogue logic
            if (npc.itemType === 'straum') {
                if (npc.hasCompletedQuest) {
                    currentPages = npc.completedDialogue;
                } else if (dialogue.showingStraumDiamondDeclined && npc.diamondNoDialogue) {
                    currentPages = npc.diamondNoDialogue;
                } else if (dialogue.showingStraumDiamond) {
                    // Stay on outOfCoinsDialogue until choice is handled
                    currentPages = npc.outOfCoinsDialogue;
                } else if (dialogue.showingStraumDropped && npc.droppedCoinsDialogue) {
                    currentPages = npc.droppedCoinsDialogue;
                } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                    currentPages = npc.declinedDialogue;
                } else if (npc.coinsInventory === 0 && !npc.diamondGiven) {
                    currentPages = npc.outOfCoinsDialogue;
                } else if (playerDroppedCoins && npc.coinsInventory > 0) {
                    currentPages = npc.droppedCoinsDialogue;
                }
            } else if (npc.name === 'Tim' && npc.needsWorkTools && !npc.workToolsGiven) {
                currentPages = npc.workToolsDialogue;
            } else if (npc.name === 'Tim' && npc.workToolsGiven) {
                currentPages = npc.workToolsCompletedDialogue;
            } else if (npc.name === 'Wheaton' && npc.jobAccepted && npc.allAnimalsRetrieved) {
                currentPages = npc.completedDialogue;
            } else if (npc.name === 'Wheaton' && npc.jobAccepted && npc.firstRetrievalCompleted) {
                currentPages = npc.activeJobDialogue;
            } else if (npc.name === 'Wheaton' && npc.jobAccepted && !npc.firstRetrievalCompleted) {
                currentPages = npc.retrievalDialogue;
            } else if (npc.name === 'Wheaton' && dialogue.showingNeedsWorkTools) {
                currentPages = npc.needsWorkToolsDialogue;
            } else if (npc.name === 'Weadon' && jobs.courierDeliveriesToday >= 3) {
                currentPages = npc.completedDeliveriesDialogue;
            } else if (npc.name === 'Weadon' && jobs.currentPackage !== null) {
                currentPages = npc.activeDeliveryDialogue;
            } else if (npc.name === 'Weadon' && npc.jobAccepted && !npc.firstDeliveryMade) {
                currentPages = npc.firstPackageDialogue;
            } else if (npc.name === 'Weadon' && dialogue.showingNeedsWorkTools) {
                currentPages = npc.needsWorkToolsDialogue;
            } else if (npc.name === 'Pin') {
                // Pin's progressive dialogue based on chain length
                if (pinChain.links >= 100 && npc.diamondGiven) {
                    currentPages = npc.completedDialogue;
                } else if (pinChain.links >= 100 && !npc.diamondGiven) {
                    currentPages = npc.hundredLinksDialogue;
                } else if (pinChain.links >= 50) {
                    currentPages = npc.fiftyLinksDialogue;
                } else if (pinChain.links >= 20) {
                    currentPages = npc.twentyLinksDialogue;
                } else if (pinChain.links >= 10) {
                    currentPages = npc.tenLinksDialogue;
                } else {
                    currentPages = npc.dialogue;
                }
            } else if (npc.name === 'Klaus') {
                // Klaus only gives disk when Pin has 50+ links
                if (npc.itemGiven) {
                    currentPages = npc.completedDialogue;
                } else if (pinChain.links >= 50) {
                    currentPages = npc.pinReadyDialogue;
                } else {
                    currentPages = npc.dialogue;
                }
            } else if (npc.name === 'Brot') {
                // Brot's progressive dialogue based on animals collected
                if (npc.hasCompletedQuest) {
                    currentPages = npc.completedDialogue;
                } else if (npc.animalsCollected >= 50 && !npc.itemGiven) {
                    currentPages = npc.fiftyAnimalsDialogue;
                } else if (npc.animalsCollected >= 25) {
                    currentPages = npc.twentyFiveAnimalsDialogue;
                } else if (npc.animalsCollected >= 10) {
                    currentPages = npc.tenAnimalsDialogue;
                } else if (npc.animalsCollected >= 5) {
                    currentPages = npc.fiveAnimalsDialogue;
                } else if (npc.animalsCollected >= 1) {
                    currentPages = npc.oneAnimalDialogue;
                } else {
                    currentPages = npc.dialogue;
                }
            } else if (npc.name === 'Noodles') {
                // Noodles only gives disk when player chain has 750+ links
                if (npc.itemGiven) {
                    currentPages = npc.completedDialogue;
                } else if (chain.links >= 750) {
                    currentPages = npc.linksReadyDialogue;
                } else {
                    currentPages = npc.dialogue;
                }
            } else if (npc.name === 'Clint') {
                // Clint's dialogue depends on following state
                if (dialogue.showingYesDialogue && npc.yesDialogue) {
                    currentPages = npc.yesDialogue;
                } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                    currentPages = npc.declinedDialogue;
                } else if (npc.isFollowing) {
                    currentPages = npc.followingDialogue;
                } else {
                    currentPages = npc.dialogue;
                }
            } else if (npc.name === 'Ram') {
                // Ram's dialogue handling
                if (npc.itemGiven) {
                    currentPages = npc.completedDialogue;
                } else if (dialogue.showingNoDiamondDialogue && npc.noDiamondDialogue) {
                    currentPages = npc.noDiamondDialogue;
                } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                    currentPages = npc.declinedDialogue;
                } else if (totalCarrying >= modifiers.carryCapacity && npc.fullDialogue) {
                    currentPages = npc.fullDialogue;
                } else {
                    currentPages = npc.dialogue;
                }
            } else if (npc.itemGiven) {
                currentPages = npc.completedDialogue;
            } else if (npc.isCollecting && npc.collectingDialogue) {
                currentPages = npc.collectingDialogue.map(page =>
                    page.map(sentence => sentence.replace('X', npc.requiresCoins - npc.coinsCollected))
                );
            } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                currentPages = npc.declinedDialogue;
            } else if (npc.itemType && totalCarrying >= modifiers.carryCapacity && npc.fullDialogue) {
                currentPages = npc.fullDialogue;
            }

            // Check if we should transition BEFORE incrementing (using current pages)
            if (dialogue.currentPage + 1 >= currentPages.length) {
                // We're about to go past the end - check if we should transition

                // Straum special transitions
                if (npc.itemType === 'straum') {
                    if (dialogue.showingStraumDropped) {
                        // After showing dropped coins dialogue, reset and go back to normal
                        dialogue.currentPage = 0;
                        dialogue.showingStraumDropped = false;
                        playerDroppedCoins = false; // Reset the flag
                        return;
                    } else if (dialogue.showingStraumDiamond && dialogue.choiceResult === 'yes') {
                        // Give diamond and end
                        giveItemToPlayer(npc);
                        dialogue.currentPage = 0;
                        dialogue.choiceResult = null;
                        dialogue.showingStraumDiamond = false;
                        endDialogue();
                        return;
                    } else if (dialogue.showingStraumDiamond && dialogue.choiceResult === 'no' && !dialogue.showingStraumDiamondDeclined) {
                        // Show diamond decline message first
                        dialogue.currentPage = 0;
                        dialogue.choiceResult = null;
                        dialogue.showingStraumDiamond = false;
                        dialogue.showingStraumDiamondDeclined = true;
                        return;
                    } else if (dialogue.showingStraumDiamondDeclined) {
                        // After showing decline message, mark as completed and end
                        npc.hasCompletedQuest = true;
                        dialogue.currentPage = 0;
                        dialogue.showingStraumDiamondDeclined = false;
                        endDialogue();
                        return;
                    } else if (dialogue.choiceResult === 'yes' && npc.coinsInventory > 0 && !dialogue.showingStraumDropped) {
                        // Give coins and close dialogue
                        giveItemToPlayer(npc);
                        dialogue.currentPage = 0;
                        dialogue.choiceResult = null;
                        endDialogue();
                        return;
                    } else if (dialogue.choiceResult === 'no' && !dialogue.showingDeclinedDialogue) {
                        // Show declined dialogue
                        dialogue.currentPage = 0;
                        dialogue.choiceResult = null;
                        dialogue.showingDeclinedDialogue = true;
                        return;
                    }
                } else if (npc.name === 'Wheaton' && dialogue.choiceResult === 'yes' && !dialogue.showingNeedsWorkTools) {
                    // Handle Wheaton job acceptance (only if not already showing needsWorkTools)
                    if (!game.hasWorkTools) {
                        // Player needs work tools - send them to Tim
                        const timNpc = npcs.find(n => n.name === 'Tim');
                        if (timNpc) {
                            timNpc.needsWorkTools = true;
                        }
                        // Transition to needsWorkTools dialogue without restarting
                        dialogue.showingNeedsWorkTools = true;
                        dialogue.choiceResult = null;
                        dialogue.currentPage = -1; // Will increment to 0 next
                        // Don't return - let it continue to increment and show the new dialogue
                    } else {
                        // Player has work tools - accept job
                        npc.jobAccepted = true;
                        jobs.hasSorter = true;
                        // Spawn initial farm animals
                        spawnFarmAnimals();
                        // Transition to retrievalDialogue
                        dialogue.choiceResult = null;
                        dialogue.currentPage = -1; // Will increment to 0 next
                        // Don't return - let it continue to show retrievalDialogue
                    }
                } else if (npc.name === 'Weadon' && dialogue.choiceResult === 'yes' && !dialogue.showingNeedsWorkTools) {
                    // Handle Weadon job acceptance (only if not already showing needsWorkTools)
                    if (!game.hasWorkTools) {
                        // Player needs work tools - send them to Tim
                        const timNpc = npcs.find(n => n.name === 'Tim');
                        if (timNpc) {
                            timNpc.needsWorkTools = true;
                        }
                        // Transition to needsWorkTools dialogue without restarting
                        dialogue.showingNeedsWorkTools = true;
                        dialogue.choiceResult = null;
                        dialogue.currentPage = -1; // Will increment to 0 next
                        // Don't return - let it continue to increment and show the new dialogue
                    } else {
                        // Player has work tools - accept job
                        npc.jobAccepted = true;
                        jobs.hasCourier = true;
                        // Give first package to Eddie
                        const eddie = npcs.find(n => n.name === 'Eddie');
                        if (eddie) {
                            givePackageToPlayer('Eddie', 5);
                            npc.firstDeliveryMade = false;
                        }
                        // Transition to firstPackageDialogue
                        dialogue.choiceResult = null;
                        dialogue.currentPage = -1; // Will increment to 0 next
                        // Don't return - let it continue to show firstPackageDialogue
                    }
                } else if (npc.name === 'Pin' && pinChain.links >= 100 && !npc.diamondGiven && currentPages === npc.hundredLinksDialogue) {
                    // Give diamond to player
                    player.carryingItems.push({
                        type: 'diamond',
                        slowAmount: 1
                    });
                    npc.diamondGiven = true;
                    dialogue.currentPage = 0;
                    endDialogue();
                    return;
                } else if (npc.name === 'Brot' && npc.animalsCollected >= 50 && !npc.itemGiven && currentPages === npc.fiftyAnimalsDialogue) {
                    // Give White Diamond to player (worth 100 coins, weighs 100)
                    player.carryingItems.push({
                        type: 'diamond',
                        name: 'White Diamond',
                        coinValue: 100,
                        slowAmount: 100
                    });
                    npc.itemGiven = true;
                    npc.hasCompletedQuest = true;
                    npc.refusesToCollectCoins = false; // Now Brot will collect coins
                    dialogue.currentPage = 0;
                    endDialogue();
                    return;
                } else if (npc.name === 'Ram' && dialogue.choiceResult === 'yes' && !npc.itemGiven && !npc.isCollectingDiamond) {
                    // Check if player has a regular diamond (any except White Diamond/Golden Fleece)
                    const hasRegularDiamond = player.carryingItems.some(item =>
                        item.type === 'diamond' &&
                        item.slowAmount !== 100 &&
                        item.name !== 'White Diamond'
                    );

                    if (!hasRegularDiamond) {
                        // Show no diamond dialogue
                        dialogue.currentPage = 0;
                        dialogue.choiceResult = null;
                        dialogue.showingNoDiamondDialogue = true;
                        return;
                    }

                    // Check if player has space for the ability
                    if (player.carryingItems.length >= modifiers.carryCapacity) {
                        // Show full inventory dialogue
                        dialogue.currentPage = 0;
                        dialogue.choiceResult = null;
                        return; // fullDialogue will be shown
                    }

                    // Player has diamond and space - start collecting
                    npc.isCollectingDiamond = true;
                    dialogue.choiceResult = null;
                    // Diamond collection happens immediately on next proximity check
                    endDialogue();
                    return;
                } else if (dialogue.choiceResult === 'yes' && npc.requiresCoins > 0 && !npc.itemGiven && !npc.isCollecting) {
                    // For paid items - enter collecting mode and show collecting dialogue
                    npc.isCollecting = true;
                    dialogue.currentPage = 0;
                    dialogue.choiceResult = null;
                    return; // Continue to collecting dialogue
                } else if (npc.name === 'Clint' && dialogue.choiceResult === 'yes' && !npc.isFollowing) {
                    // Clint starts following the player
                    npc.isFollowing = true;
                    npc.hasCompletedQuest = true;
                    // Determine which side to follow on based on current position
                    const dxToPlayer = player.x - npc.x;
                    npc.followSide = dxToPlayer > 0 ? -1 : 1; // Follow on opposite side of approach
                    dialogue.currentPage = 0;
                    dialogue.choiceResult = null;
                    dialogue.showingYesDialogue = true;
                    return;
                } else if (dialogue.choiceResult === 'no' && npc.declinedDialogue && !dialogue.showingDeclinedDialogue) {
                    // For declined choices - show declined dialogue (only transition once)
                    dialogue.currentPage = 0;
                    dialogue.choiceResult = null;
                    dialogue.showingDeclinedDialogue = true;
                    return; // Continue to declined dialogue
                }
            }

            dialogue.currentPage++;

            // NOW determine which dialogue to show (AFTER incrementing)
            if (npc.itemType === 'straum') {
                if (npc.hasCompletedQuest) {
                    pages = npc.completedDialogue;
                } else if (dialogue.showingStraumDiamondDeclined && npc.diamondNoDialogue) {
                    pages = npc.diamondNoDialogue;
                } else if (dialogue.showingStraumDiamond) {
                    // Stay on outOfCoinsDialogue until choice is handled
                    pages = npc.outOfCoinsDialogue;
                } else if (dialogue.showingStraumDropped && npc.droppedCoinsDialogue) {
                    pages = npc.droppedCoinsDialogue;
                } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                    pages = npc.declinedDialogue;
                } else if (npc.coinsInventory === 0 && !npc.diamondGiven) {
                    pages = npc.outOfCoinsDialogue;
                } else if (playerDroppedCoins && npc.coinsInventory > 0) {
                    pages = npc.droppedCoinsDialogue;
                }
            } else if (npc.name === 'Tim' && npc.needsWorkTools && !npc.workToolsGiven) {
                pages = npc.workToolsDialogue;
            } else if (npc.name === 'Tim' && npc.workToolsGiven) {
                pages = npc.workToolsCompletedDialogue;
            } else if (npc.name === 'Wheaton' && npc.jobAccepted && npc.allAnimalsRetrieved) {
                pages = npc.completedDialogue;
            } else if (npc.name === 'Wheaton' && npc.jobAccepted && npc.firstRetrievalCompleted) {
                pages = npc.activeJobDialogue;
            } else if (npc.name === 'Wheaton' && npc.jobAccepted && !npc.firstRetrievalCompleted) {
                pages = npc.retrievalDialogue;
            } else if (npc.name === 'Wheaton' && dialogue.showingNeedsWorkTools) {
                pages = npc.needsWorkToolsDialogue;
            } else if (npc.name === 'Weadon' && jobs.courierDeliveriesToday >= 3) {
                pages = npc.completedDeliveriesDialogue;
            } else if (npc.name === 'Weadon' && jobs.currentPackage !== null) {
                const deadline = jobs.packageDeadline;
                const timeString = deadline ? `${deadline.getHours().toString().padStart(2, '0')}:${deadline.getMinutes().toString().padStart(2, '0')}` : 'UNKNOWN';
                const targetNpcName = jobs.currentPackage.targetNpc || 'UNKNOWN';
                pages = npc.activeDeliveryDialogue.map(page =>
                    page.map(sentence => sentence.replace('TIME_PLACEHOLDER', timeString).replace('NPC_PLACEHOLDER', targetNpcName))
                );
            } else if (npc.name === 'Weadon' && npc.jobAccepted && !npc.firstDeliveryMade) {
                pages = npc.firstPackageDialogue;
            } else if (npc.name === 'Weadon' && dialogue.showingNeedsWorkTools) {
                pages = npc.needsWorkToolsDialogue;
            } else if (npc.name === 'Pin') {
                // Pin's progressive dialogue based on chain length
                if (pinChain.links >= 100 && npc.diamondGiven) {
                    pages = npc.completedDialogue;
                } else if (pinChain.links >= 100 && !npc.diamondGiven) {
                    pages = npc.hundredLinksDialogue;
                } else if (pinChain.links >= 50) {
                    pages = npc.fiftyLinksDialogue;
                } else if (pinChain.links >= 20) {
                    pages = npc.twentyLinksDialogue;
                } else if (pinChain.links >= 10) {
                    pages = npc.tenLinksDialogue;
                } else {
                    pages = npc.dialogue;
                }
            } else if (npc.name === 'Klaus') {
                // Klaus only gives disk when Pin has 50+ links
                if (npc.itemGiven) {
                    pages = npc.completedDialogue;
                } else if (pinChain.links >= 50) {
                    pages = npc.pinReadyDialogue;
                } else {
                    pages = npc.dialogue;
                }
            } else if (npc.name === 'Brot') {
                // Brot's progressive dialogue based on animals collected
                if (npc.hasCompletedQuest) {
                    pages = npc.completedDialogue;
                } else if (npc.animalsCollected >= 50 && !npc.itemGiven) {
                    pages = npc.fiftyAnimalsDialogue;
                } else if (npc.animalsCollected >= 25) {
                    pages = npc.twentyFiveAnimalsDialogue;
                } else if (npc.animalsCollected >= 10) {
                    pages = npc.tenAnimalsDialogue;
                } else if (npc.animalsCollected >= 5) {
                    pages = npc.fiveAnimalsDialogue;
                } else if (npc.animalsCollected >= 1) {
                    pages = npc.oneAnimalDialogue;
                } else {
                    pages = npc.dialogue;
                }
            } else if (npc.name === 'Noodles') {
                // Noodles only gives disk when player chain has 750+ links
                if (npc.itemGiven) {
                    pages = npc.completedDialogue;
                } else if (chain.links >= 750) {
                    pages = npc.linksReadyDialogue;
                } else {
                    pages = npc.dialogue;
                }
            } else if (npc.name === 'Clint') {
                // Clint's dialogue depends on following state
                if (dialogue.showingYesDialogue && npc.yesDialogue) {
                    pages = npc.yesDialogue;
                } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                    pages = npc.declinedDialogue;
                } else if (npc.isFollowing) {
                    pages = npc.followingDialogue;
                } else {
                    pages = npc.dialogue;
                }
            } else if (npc.name === 'Ram') {
                // Ram's dialogue handling
                if (npc.itemGiven) {
                    pages = npc.completedDialogue;
                } else if (dialogue.showingNoDiamondDialogue && npc.noDiamondDialogue) {
                    pages = npc.noDiamondDialogue;
                } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                    pages = npc.declinedDialogue;
                } else if (totalCarrying >= modifiers.carryCapacity && npc.fullDialogue) {
                    pages = npc.fullDialogue;
                } else {
                    pages = npc.dialogue;
                }
            } else if (npc.itemGiven) {
                pages = npc.completedDialogue;
            } else if (npc.isCollecting && npc.collectingDialogue) {
                pages = npc.collectingDialogue.map(page =>
                    page.map(sentence => sentence.replace('X', npc.requiresCoins - npc.coinsCollected))
                );
            } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                pages = npc.declinedDialogue;
            } else if (npc.itemType && totalCarrying >= modifiers.carryCapacity && npc.fullDialogue) {
                pages = npc.fullDialogue;
            }

            if (dialogue.currentPage >= pages.length) {
                // End of dialogue

                // Handle Wes special case - give item and close immediately
                if (npc.endOnAccept && dialogue.choiceResult === 'yes' && !npc.itemGiven && totalCarrying < modifiers.carryCapacity) {
                    giveItemToPlayer(npc);
                    endDialogue();
                    return;
                }

                // For free items (no coins required)
                // Klaus only gives disk when Pin has 50+ links
                const klausCanGive = npc.name !== 'Klaus' || pinChain.links >= 50;
                // Noodles only gives disk when player chain has 750+ links
                const noodlesCanGive = npc.name !== 'Noodles' || chain.links >= 750;
                // Ram requires diamond payment, not free
                const notRamDiamond = !npc.requiresDiamond;
                // For NPCs with choices, require explicit 'yes'; for others, just not 'no'
                const choiceOk = npc.hasChoice ? dialogue.choiceResult === 'yes' : dialogue.choiceResult !== 'no';
                if (!npc.itemGiven && npc.itemType && choiceOk && totalCarrying < modifiers.carryCapacity && npc.requiresCoins === 0 && klausCanGive && noodlesCanGive && notRamDiamond) {
                    giveItemToPlayer(npc);
                }

                // Tim giving work tools (special case)
                if (npc.name === 'Tim' && npc.needsWorkTools && !npc.workToolsGiven && totalCarrying < modifiers.carryCapacity) {
                    giveItemToPlayer(npc);
                }

                // Mark NPCs with no items as completed when their dialogue is exhausted
                if (!npc.itemType && !npc.hasCompletedQuest) {
                    npc.hasCompletedQuest = true;
                }

                endDialogue();
            } else {
                // Check if next page has a choice
                if (npc.itemType === 'straum') {
                    // Straum shows choices for coin offer and diamond offer
                    if (npc.hasChoice && dialogue.currentPage === pages.length - 1) {
                        // Show choice if we're on the coin offer or diamond offer dialogue
                        if ((npc.coinsInventory > 0 && !dialogue.showingStraumDropped && !dialogue.showingDeclinedDialogue) ||
                            (npc.coinsInventory === 0 && !npc.diamondGiven && dialogue.showingStraumDiamond)) {
                            dialogue.pendingChoice = true;
                        }
                    }
                } else if (npc.hasChoice && dialogue.currentPage === pages.length - 1 && !npc.itemGiven && !npc.isCollecting && totalCarrying < modifiers.carryCapacity && !dialogue.showingDeclinedDialogue && !dialogue.showingNeedsWorkTools && !dialogue.showingNoDiamondDialogue) {
                    // Don't show choice for job NPCs when job is already accepted
                    if (npc.name === 'Weadon' && (npc.jobAccepted || jobs.currentPackage !== null || jobs.courierDeliveriesToday >= 3)) {
                        // No choice for Weadon's active job dialogues
                    } else if (npc.name === 'Wheaton' && npc.jobAccepted) {
                        // No choice for Wheaton's active job dialogues
                    } else {
                        // Only show choice if not in declined or needsWorkTools dialogue
                        dialogue.pendingChoice = true;
                    }
                }
            }
        }

        function previousDialogue() {
            if (dialogue.currentPage > 0) {
                dialogue.currentPage--;
                dialogue.pendingChoice = false;
            }
        }

        function endDialogue() {
            dialogue.active = false;
            dialogue.lastNpc = dialogue.npc; // Remember which NPC we just talked to
            dialogue.npc = null;
            dialogue.currentPage = 0;
            dialogue.pendingChoice = false;
            dialogue.choiceResult = null;
            dialogue.showingDeclinedDialogue = false; // Reset declined dialogue flag
            dialogue.showingNeedsWorkTools = false; // Reset needs work tools flag
            dialogue.showingNoDiamondDialogue = false; // Reset Ram no diamond flag
            dialogue.showingStraumDropped = false; // Reset Straum flags
            dialogue.showingStraumDiamond = false;
            dialogue.showingStraumDiamondDeclined = false;
            dialogue.cooldownTimer = 1.0; // 1 second cooldown before same NPC can trigger again
            game.paused = false;
        }

        function giveItemToPlayer(npc) {
            // Special handling for Tim giving work tools
            if (npc.name === 'Tim' && npc.needsWorkTools && !npc.workToolsGiven) {
                if (player.carryingItems.length >= modifiers.carryCapacity) {
                    return;
                }
                player.carryingItems.push({
                    type: 'workTools',
                    name: 'Work Tools'
                });
                npc.workToolsGiven = true;
                audio.receivedGift.play();
                return;
            }

            if (npc.itemType === 'straum') {
                // Straum can give coins or diamond depending on state
                if (!npc.diamondGiven && npc.coinsInventory === 0) {
                    // Give diamond
                    if (player.carryingItems.length >= modifiers.carryCapacity) {
                        return;
                    }
                    player.carryingItems.push({
                        type: 'diamond',
                        coinValue: 10,
                        slowAmount: 10
                    });
                    npc.diamondGiven = true;
                    npc.hasCompletedQuest = true;
                    audio.receivedGift.play();
                } else if (npc.coinsInventory > 0) {
                    // Give coins - as many as player can carry
                    const spaceForCoins = modifiers.carryCapacity - player.carryingCoins.length;
                    const coinsToGive = Math.min(npc.coinsInventory, spaceForCoins);

                    for (let i = 0; i < coinsToGive; i++) {
                        player.carryingCoins.push({
                            radius: 8,
                            color: '#fff',
                            collected: true
                        });
                    }

                    npc.coinsInventory -= coinsToGive;
                    audio.receivedGift.play();
                }
            } else if (npc.itemType === 'diamond') {
                // Check if player has space
                if (player.carryingItems.length >= modifiers.carryCapacity) {
                    return;
                }

                // Add diamond as special item
                player.carryingItems.push({
                    type: 'diamond',
                    coinValue: 10,
                    slowAmount: 10
                });
                npc.itemGiven = true;
                npc.hasCompletedQuest = true;
                audio.receivedGift.play();
            } else if (npc.itemType === 'ability') {
                // Check if player has space
                if (player.carryingItems.length >= modifiers.carryCapacity) {
                    return;
                }

                // Add ability item
                player.carryingItems.push({
                    type: 'ability',
                    name: npc.abilityName,
                    effect: npc.abilityEffect
                });
                npc.itemGiven = true;
                npc.hasCompletedQuest = true;
                audio.receivedGift.play();
            } else if (npc.itemType === 'homeBeacon') {
                // Coins are already taken before this function is called
                // Check if player has space
                if (player.carryingItems.length >= modifiers.carryCapacity) {
                    return;
                }

                // Add beacon item
                player.carryingItems.push({
                    type: 'homeBeacon'
                });
                npc.itemGiven = true;
                npc.hasCompletedQuest = true;
                audio.receivedGift.play();
            } else if (npc.itemType === 'musicDisk') {
                // Check if player has space
                if (player.carryingItems.length >= modifiers.carryCapacity) {
                    return;
                }

                // Add music disk item
                player.carryingItems.push({
                    type: 'musicDisk',
                    name: npc.diskName,
                    trackPaths: npc.trackPaths
                });
                npc.itemGiven = true;
                npc.hasCompletedQuest = true;
                audio.receivedGift.play();

                // If this is George, stop his music point
                if (npc.name === 'George' && georgeMusicPoint) {
                    georgeMusicPoint.audioTracks.forEach(audio => audio.pause());
                    const index = musicPoints.indexOf(georgeMusicPoint);
                    if (index > -1) {
                        musicPoints.splice(index, 1);
                    }
                    georgeMusicPoint = null;
                }

                // If this is Klaus, stop his music point
                if (npc.name === 'Klaus' && klausMusicPoint) {
                    klausMusicPoint.audioTracks.forEach(audio => audio.pause());
                    const index = musicPoints.indexOf(klausMusicPoint);
                    if (index > -1) {
                        musicPoints.splice(index, 1);
                    }
                    klausMusicPoint = null;
                }

                // If this is Noodles, stop his music point
                if (npc.name === 'Noodles' && noodlesMusicPoint) {
                    noodlesMusicPoint.audioTracks.forEach(audio => audio.pause());
                    const index = musicPoints.indexOf(noodlesMusicPoint);
                    if (index > -1) {
                        musicPoints.splice(index, 1);
                    }
                    noodlesMusicPoint = null;
                }
            }
        }

        function givePackageToPlayer(targetNpcName, weight) {
            if (player.carryingItems.length >= modifiers.carryCapacity) return;

            const deadline = new Date();
            deadline.setMinutes(deadline.getMinutes() + 10);

            player.carryingItems.push({
                type: 'package',
                targetNpc: targetNpcName,
                weight: weight,
                deadline: deadline
            });

            jobs.currentPackage = player.carryingItems[player.carryingItems.length - 1];
            jobs.packageDeadline = deadline;
        }

        // Update ability display timer
        function updateAbilityDisplay() {
            if (game.showAbilityDisplay && game.abilityDisplayTimer < game.abilityDisplayDelay) {
                game.abilityDisplayTimer += 1/60;
            } else if (game.showAbilityDisplay && game.abilityDisplayTimer >= game.abilityDisplayDelay) {
                game.showAbilityDisplay = false;
                game.paused = false;
                game.abilityDisplayTimer = 0;
            }
        }

        // Convert world position to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: ((worldX - player.x) * game.zoom) + canvas.width / 2 + game.cameraOffsetX,
                y: ((worldY - player.y) * game.zoom) + canvas.height / 2 + game.cameraOffsetY
            };
        }

        // Update camera zoom
        function updateCamera() {
            // Apply zoom from skills
            game.targetZoom = game.baseZoom * (1 - modifiers.zoomOut);

            // Smoothly interpolate zoom towards target
            game.zoom += (game.targetZoom - game.zoom) * 0.05;

            // Apply camera bounce/shake
            if (game.cameraShakeAmount > 0) {
                const bounce = Math.sin(game.cameraShakeAmount * 30) * game.cameraShakeAmount;
                game.zoom += bounce * 0.15;
                game.cameraShakeAmount *= 0.92;
                if (game.cameraShakeAmount < 0.001) {
                    game.cameraShakeAmount = 0;
                }
            }
        }

        // Update post pulse
        function updatePost() {
            if (player.carryingCoins.length > 0 || player.carryingItems.length > 0) {
                // Calculate distance to post
                const dxPost = player.x - post.x;
                const dyPost = player.y - post.y;
                const distToPost = Math.sqrt(dxPost * dxPost + dyPost * dyPost);
                const maxDist = chain.links * chain.linkLength;

                // Pulse frequency increases as player gets closer
                const proximity = 1 - Math.min(distToPost / maxDist, 1);
                const pulseSpeed = 0.05 + proximity * 0.3;

                post.pulseTime += pulseSpeed;

                // Fade between 0.3 and 1.0, faster when closer
                post.alpha = 0.3 + Math.abs(Math.sin(post.pulseTime)) * 0.7;
            } else {
                // Return to full opacity when not carrying
                post.alpha += (1.0 - post.alpha) * 0.1;
                post.pulseTime = 0;
            }
        }

        // Update floating texts
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const text = floatingTexts[i];
                text.y += text.vy;
                text.vy *= 0.95;
                text.life -= 0.015;
                text.alpha = text.life;

                if (text.life <= 0) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        // Update player movement
        function updatePlayer() {
            let inputX = 0;
            let inputY = 0;

            if (game.keys.ArrowUp) inputY -= 1;
            if (game.keys.ArrowDown) inputY += 1;
            if (game.keys.ArrowLeft) inputX -= 1;
            if (game.keys.ArrowRight) inputX += 1;

            // Check for drop command (left + right held for 300ms)
            if (game.keys.ArrowLeft && game.keys.ArrowRight) {
                const currentTime = Date.now();
                if (dropHoldStartTime === null) {
                    dropHoldStartTime = currentTime;
                } else if (currentTime - dropHoldStartTime >= 300 && currentTime - lastDropTime >= 500) {
                    dropLastItem();
                    dropHoldStartTime = null; // Reset after dropping
                }
                inputX = 0; // Cancel movement when holding drop keys
            } else {
                dropHoldStartTime = null; // Reset if keys released
            }

            const inputDist = Math.sqrt(inputX * inputX + inputY * inputY);

            // Calculate current stats with modifiers
            const currentSpeed = player.baseSpeed * (1 + modifiers.moveSpeed);
            const currentAcceleration = player.baseAcceleration * (1 + modifiers.moveAcceleration);
            const currentDeceleration = player.baseDeceleration + modifiers.moveDeceleration;

            // Calculate carrying speed with linear slowdown per coin
            let finalSpeed = currentSpeed;
            const totalCarried = player.carryingCoins.length;

            // Calculate item weight (diamonds and other items add to slowdown)
            let totalWeight = totalCarried;
            for (let item of player.carryingItems) {
                if (item.type === 'diamond') {
                    totalWeight += item.slowAmount;
                } else if (item.type === 'package') {
                    totalWeight += item.weight; // Packages have custom weight
                } else {
                    totalWeight += 1; // Regular items count as 1
                }
            }

            if (totalWeight > 0) {
                // Linear slowdown: each coin/item slows by a base amount
                const slowdownPerItem = 0.15; // 15% slowdown per item
                const basePenalty = slowdownPerItem * totalWeight;
                // Apply penalty reduction from skills
                const effectivePenalty = basePenalty * (1 - modifiers.carrySpeedPenaltyReduction);
                // Apply penalty and add bonus
                finalSpeed = currentSpeed * Math.max(0.1, 1 - effectivePenalty) * (1 + modifiers.carrySpeedBonus);

                // Max Fulfillment Coin: triple speed when carrying 10+ weight
                if (game.maxFulfillmentBoostActive) {
                    finalSpeed *= 3;
                }
            }

            // Smooth acceleration
            if (inputDist > 0) {
                const targetVx = (inputX / inputDist) * finalSpeed;
                const targetVy = (inputY / inputDist) * finalSpeed;

                player.vx += (targetVx - player.vx) * currentAcceleration;
                player.vy += (targetVy - player.vy) * currentAcceleration;
            } else {
                // Deceleration when no input
                player.vx *= currentDeceleration;
                player.vy *= currentDeceleration;
            }

            // Handle moving sound
            const velocityMag = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (velocityMag > 0.1 && !isMoving) {
                audio.movingSound.play();
                isMoving = true;
            } else if (velocityMag <= 0.1 && isMoving) {
                audio.movingSound.pause();
                audio.movingSound.currentTime = 0;
                isMoving = false;
            }

            // Apply velocity
            const oldX = player.x;
            const oldY = player.y;
            player.x += player.vx;
            player.y += player.vy;

            // Check barrier collision (circle vs rectangle)
            for (let barrier of barriers) {
                // Find closest point on rectangle to circle center
                const closestX = Math.max(barrier.x, Math.min(player.x, barrier.x + barrier.width));
                const closestY = Math.max(barrier.y, Math.min(player.y, barrier.y + barrier.height));

                // Calculate distance from closest point to circle center
                const distX = player.x - closestX;
                const distY = player.y - closestY;
                const distSquared = distX * distX + distY * distY;

                // Check if collision occurred
                if (distSquared < player.radius * player.radius) {
                    // Revert movement
                    player.x = oldX;
                    player.y = oldY;
                    // Stop velocity
                    player.vx = 0;
                    player.vy = 0;
                    break;
                }
            }

            // Constrain player to chain length
            const chainDist = Math.sqrt(player.x * player.x + player.y * player.y);
            const maxDist = chain.links * chain.linkLength;

            if (chainDist > maxDist) {
                const angle = Math.atan2(player.y, player.x);
                player.x = Math.cos(angle) * maxDist;
                player.y = Math.sin(angle) * maxDist;

                // Dampen velocity when hitting chain limit
                player.vx *= 0.5;
                player.vy *= 0.5;
            }

            // Update camera offset (CCC) - with modifier reduction
            const effectiveOffsetReduction = 1 - modifiers.cameraOffsetReduction;
            if (velocityMag > 0.1) {
                const offsetStrength = 0.5 * effectiveOffsetReduction;
                const targetOffsetX = (player.vx / velocityMag) * 100 * offsetStrength;
                const targetOffsetY = (player.vy / velocityMag) * 100 * offsetStrength;
                game.cameraOffsetX += (targetOffsetX - game.cameraOffsetX) * 0.08;
                game.cameraOffsetY += (targetOffsetY - game.cameraOffsetY) * 0.08;
            } else {
                // Smoothly return to center when stopped
                game.cameraOffsetX *= 0.95;
                game.cameraOffsetY *= 0.95;
            }
        }

        // Check if line segment intersects rectangle
        function lineIntersectsRect(x1, y1, x2, y2, rectX, rectY, rectW, rectH) {
            // Check if either endpoint is inside the rectangle
            if ((x1 >= rectX && x1 <= rectX + rectW && y1 >= rectY && y1 <= rectY + rectH) ||
                (x2 >= rectX && x2 <= rectX + rectW && y2 >= rectY && y2 <= rectY + rectH)) {
                return true;
            }

            // Check intersection with each edge of the rectangle
            // Top edge
            if (lineIntersectsLine(x1, y1, x2, y2, rectX, rectY, rectX + rectW, rectY)) return true;
            // Bottom edge
            if (lineIntersectsLine(x1, y1, x2, y2, rectX, rectY + rectH, rectX + rectW, rectY + rectH)) return true;
            // Left edge
            if (lineIntersectsLine(x1, y1, x2, y2, rectX, rectY, rectX, rectY + rectH)) return true;
            // Right edge
            if (lineIntersectsLine(x1, y1, x2, y2, rectX + rectW, rectY, rectX + rectW, rectY + rectH)) return true;

            return false;
        }

        // Check if two line segments intersect
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denom === 0) return false; // Parallel lines

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

            return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
        }

        // Inverse kinematics for chain
        function updateChain() {
            // Safety check
            if (chain.segments.length === 0) return;

            // Last segment follows player
            chain.segments[chain.segments.length - 1].x = player.x;
            chain.segments[chain.segments.length - 1].y = player.y;

            // FABRIK algorithm with multiple passes for rigidity
            const iterations = 5; // More iterations = more rigid chain
            const segmentRadius = 8; // Larger radius for more physical collision

            for (let iter = 0; iter < iterations; iter++) {
                // Forward pass
                for (let i = chain.segments.length - 2; i >= 0; i--) {
                    const curr = chain.segments[i];
                    const next = chain.segments[i + 1];
                    const oldX = curr.x;
                    const oldY = curr.y;
                    const dx = curr.x - next.x;
                    const dy = curr.y - next.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const ratio = chain.linkLength / dist;
                        curr.x = next.x + dx * ratio;
                        curr.y = next.y + dy * ratio;

                        // Check if new position creates a link through a barrier
                        for (let barrier of barriers) {
                            if (lineIntersectsRect(curr.x, curr.y, next.x, next.y, barrier.x, barrier.y, barrier.width, barrier.height)) {
                                // Revert this movement
                                curr.x = oldX;
                                curr.y = oldY;
                                break;
                            }
                        }
                    }
                }

                // Backward pass - anchor to post
                chain.segments[0].x = post.x;
                chain.segments[0].y = post.y;

                for (let i = 1; i < chain.segments.length; i++) {
                    const prev = chain.segments[i - 1];
                    const curr = chain.segments[i];
                    const oldX = curr.x;
                    const oldY = curr.y;
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const ratio = chain.linkLength / dist;
                        curr.x = prev.x + dx * ratio;
                        curr.y = prev.y + dy * ratio;

                        // Check if new position creates a link through a barrier
                        for (let barrier of barriers) {
                            if (lineIntersectsRect(prev.x, prev.y, curr.x, curr.y, barrier.x, barrier.y, barrier.width, barrier.height)) {
                                // Revert this movement
                                curr.x = oldX;
                                curr.y = oldY;
                                break;
                            }
                        }
                    }
                }
            }

            // Final collision resolution pass - apply multiple times for strictness
            for (let collisionIter = 0; collisionIter < 15; collisionIter++) {
                // Check point collisions
                for (let i = 0; i < chain.segments.length; i++) {
                    const curr = chain.segments[i];

                    for (let barrier of barriers) {
                        const closestX = Math.max(barrier.x, Math.min(curr.x, barrier.x + barrier.width));
                        const closestY = Math.max(barrier.y, Math.min(curr.y, barrier.y + barrier.height));
                        const distX = curr.x - closestX;
                        const distY = curr.y - closestY;
                        const distSquared = distX * distX + distY * distY;

                        if (distSquared < segmentRadius * segmentRadius) {
                            // Push segment away from barrier
                            const collisionDist = Math.sqrt(distSquared);
                            if (collisionDist > 0) {
                                const pushDist = segmentRadius - collisionDist + 2.0; // Extra padding
                                curr.x += (distX / collisionDist) * pushDist;
                                curr.y += (distY / collisionDist) * pushDist;
                            } else {
                                // If exactly on the point, push in a default direction
                                curr.x += segmentRadius * 1.5;
                            }
                        }
                    }
                }

                // Check link collisions (lines between segments)
                for (let i = 1; i < chain.segments.length; i++) {
                    const prev = chain.segments[i - 1];
                    const curr = chain.segments[i];

                    for (let barrier of barriers) {
                        if (lineIntersectsRect(prev.x, prev.y, curr.x, curr.y, barrier.x, barrier.y, barrier.width, barrier.height)) {
                            // Link passes through barrier - push current segment away
                            // Find which side of barrier is closest and push away from that
                            const centerX = barrier.x + barrier.width / 2;
                            const centerY = barrier.y + barrier.height / 2;
                            const dx = curr.x - centerX;
                            const dy = curr.y - centerY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                // Push in direction away from barrier center
                                const pushAmount = segmentRadius + 5;
                                curr.x += (dx / dist) * pushAmount;
                                curr.y += (dy / dist) * pushAmount;
                            }
                        }
                    }
                }

                // Re-constrain segments to maintain chain length after collision resolution
                // Backward pass only (to keep post anchored)
                chain.segments[0].x = post.x;
                chain.segments[0].y = post.y;

                for (let i = 1; i < chain.segments.length; i++) {
                    const prev = chain.segments[i - 1];
                    const curr = chain.segments[i];
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Always enforce exact chain length, not just when too long
                    if (dist > 0.01) {
                        const ratio = chain.linkLength / dist;
                        curr.x = prev.x + dx * ratio;
                        curr.y = prev.y + dy * ratio;
                    }
                }
            }

            // Final FABRIK pass to ensure chain integrity after all collisions
            chain.segments[0].x = post.x;
            chain.segments[0].y = post.y;
            chain.segments[chain.segments.length - 1].x = player.x;
            chain.segments[chain.segments.length - 1].y = player.y;

            // Backward pass from player to post
            for (let i = chain.segments.length - 2; i >= 0; i--) {
                const curr = chain.segments[i];
                const next = chain.segments[i + 1];
                const dx = curr.x - next.x;
                const dy = curr.y - next.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const ratio = chain.linkLength / dist;
                    curr.x = next.x + dx * ratio;
                    curr.y = next.y + dy * ratio;
                }
            }

            // Forward pass from post to player
            chain.segments[0].x = post.x;
            chain.segments[0].y = post.y;

            for (let i = 1; i < chain.segments.length; i++) {
                const prev = chain.segments[i - 1];
                const curr = chain.segments[i];
                const dx = curr.x - prev.x;
                const dy = curr.y - prev.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const ratio = chain.linkLength / dist;
                    curr.x = prev.x + dx * ratio;
                    curr.y = prev.y + dy * ratio;
                }
            }
        }

        // Update Pin's chain (same physics as player chain)
        function updatePinChain() {
            const pin = npcs.find(n => n.name === 'Pin');
            if (!pin) return;

            // Safety check
            if (pinChain.segments.length === 0) return;

            // Last segment follows Pin
            pinChain.segments[pinChain.segments.length - 1].x = pin.x;
            pinChain.segments[pinChain.segments.length - 1].y = pin.y;

            // FABRIK algorithm with multiple passes for rigidity
            const iterations = 5;

            for (let iter = 0; iter < iterations; iter++) {
                // Forward pass
                for (let i = pinChain.segments.length - 2; i >= 0; i--) {
                    const curr = pinChain.segments[i];
                    const next = pinChain.segments[i + 1];
                    const dx = curr.x - next.x;
                    const dy = curr.y - next.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const ratio = pinChain.linkLength / dist;
                        curr.x = next.x + dx * ratio;
                        curr.y = next.y + dy * ratio;
                    }
                }

                // Backward pass - anchor to Pin's post
                pinChain.segments[0].x = pinPost.x;
                pinChain.segments[0].y = pinPost.y;

                for (let i = 1; i < pinChain.segments.length; i++) {
                    const prev = pinChain.segments[i - 1];
                    const curr = pinChain.segments[i];
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        const ratio = pinChain.linkLength / dist;
                        curr.x = prev.x + dx * ratio;
                        curr.y = prev.y + dy * ratio;
                    }
                }
            }

            // Final FABRIK pass to ensure chain integrity
            pinChain.segments[0].x = pinPost.x;
            pinChain.segments[0].y = pinPost.y;
            pinChain.segments[pinChain.segments.length - 1].x = pin.x;
            pinChain.segments[pinChain.segments.length - 1].y = pin.y;

            // Backward pass from Pin to post
            for (let i = pinChain.segments.length - 2; i >= 0; i--) {
                const curr = pinChain.segments[i];
                const next = pinChain.segments[i + 1];
                const dx = curr.x - next.x;
                const dy = curr.y - next.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const ratio = pinChain.linkLength / dist;
                    curr.x = next.x + dx * ratio;
                    curr.y = next.y + dy * ratio;
                }
            }

            // Forward pass from post to Pin
            pinChain.segments[0].x = pinPost.x;
            pinChain.segments[0].y = pinPost.y;

            for (let i = 1; i < pinChain.segments.length; i++) {
                const prev = pinChain.segments[i - 1];
                const curr = pinChain.segments[i];
                const dx = curr.x - prev.x;
                const dy = curr.y - prev.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const ratio = pinChain.linkLength / dist;
                    curr.x = prev.x + dx * ratio;
                    curr.y = prev.y + dy * ratio;
                }
            }
        }

        // Update Pin's AI behavior
        function updatePin() {
            const pin = npcs.find(n => n.name === 'Pin');
            if (!pin) return;

            // Check if player is close enough to stop Pin's movement
            const dx = player.x - pin.x;
            const dy = player.y - pin.y;
            const distToPlayer = Math.sqrt(dx * dx + dy * dy);

            // Stop moving if player is within 12 radius
            if (distToPlayer <= 12) {
                return;
            }

            // Calculate max chain reach
            const maxChainReach = pinChain.links * pinChain.linkLength;

            // If carrying a coin, return to post
            if (pin.carryingCoin !== null) {
                const dxPost = pinPost.x - pin.x;
                const dyPost = pinPost.y - pin.y;
                const distToPost = Math.sqrt(dxPost * dxPost + dyPost * dyPost);

                // Check if right next to post (within 5 pixels)
                if (distToPost < 5) {
                    // Deposit coin and grow chain
                    pinChain.links++;
                    pinChain.segments.push({
                        x: pinPost.x,
                        y: pinPost.y
                    });
                    pin.carryingCoin = null;
                    pin.returningToPost = false;
                    pin.targetCoinIndex = -1;
                } else {
                    // Move toward post at speed 1
                    const moveX = (dxPost / distToPost) * 1;
                    const moveY = (dyPost / distToPost) * 1;
                    const newX = pin.x + moveX;
                    const newY = pin.y + moveY;

                    // Check if new position is within chain reach
                    const newDistToPost = Math.sqrt((newX - pinPost.x) ** 2 + (newY - pinPost.y) ** 2);
                    if (newDistToPost <= maxChainReach) {
                        pin.x = newX;
                        pin.y = newY;
                    }
                }
            } else {
                // Find closest coin (regardless of chain reach)
                let closestCoinIndex = -1;
                let closestDist = Infinity;

                for (let i = 0; i < coins.length; i++) {
                    const coin = coins[i];
                    if (coin.collected) continue;

                    const dxCoin = coin.x - pin.x;
                    const dyCoin = coin.y - pin.y;
                    const distToCoin = Math.sqrt(dxCoin * dxCoin + dyCoin * dyCoin);

                    if (distToCoin < closestDist) {
                        closestDist = distToCoin;
                        closestCoinIndex = i;
                    }
                }

                // Move toward closest coin
                if (closestCoinIndex !== -1) {
                    const targetCoin = coins[closestCoinIndex];
                    const dxCoin = targetCoin.x - pin.x;
                    const dyCoin = targetCoin.y - pin.y;
                    const distToCoin = Math.sqrt(dxCoin * dxCoin + dyCoin * dyCoin);

                    // Check if close enough to pick up (within pin's radius + coin radius)
                    if (distToCoin <= pin.radius + targetCoin.radius) {
                        // Pick up the coin
                        pin.carryingCoin = targetCoin;
                        targetCoin.collected = true;
                        pin.returningToPost = true;
                    } else {
                        // Move toward coin at speed 1
                        const moveX = (dxCoin / distToCoin) * 1;
                        const moveY = (dyCoin / distToCoin) * 1;
                        const newX = pin.x + moveX;
                        const newY = pin.y + moveY;

                        // Check if new position is within chain reach
                        const newDistToPost = Math.sqrt((newX - pinPost.x) ** 2 + (newY - pinPost.y) ** 2);
                        if (newDistToPost <= maxChainReach) {
                            pin.x = newX;
                            pin.y = newY;
                        }
                    }
                }
            }
        }

        // Check coin collisions and NPC interactions
        function checkCoins() {
            const pickupRadiusMultiplier = 1 + modifiers.pickupRange;
            const maxCapacity = modifiers.carryCapacity;
            const totalCarrying = player.carryingCoins.length + player.carryingItems.length;

            for (let coin of coins) {
                if (coin.collected) continue;

                const dx = player.x - coin.x;
                const dy = player.y - coin.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Pickup coin
                const pickupRadius = (player.radius + coin.radius) * pickupRadiusMultiplier;
                if (totalCarrying < maxCapacity && dist < pickupRadius) {
                    player.carryingCoins.push(coin);
                    coin.collected = true;
                    game.coinsCollected++;

                    // Play random pickup sound
                    const randomPickup = audio.pickupSounds[Math.floor(Math.random() * audio.pickupSounds.length)];
                    randomPickup.currentTime = 0;
                    randomPickup.play();
                }
            }

            // Check dropped items for pickup
            for (let droppedItem of droppedItems) {
                if (droppedItem.collected) continue;

                const dx = player.x - droppedItem.x;
                const dy = player.y - droppedItem.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Pickup dropped item
                const pickupRadius = (player.radius + droppedItem.radius) * pickupRadiusMultiplier;
                if (totalCarrying < maxCapacity && dist < pickupRadius) {
                    let itemToPick = droppedItem.item;

                    // Restore effect function for ability items
                    if (itemToPick.type === 'ability' && !itemToPick.effect) {
                        // First check skills database
                        for (let direction in skills) {
                            const skill = skills[direction].find(s => s.name === itemToPick.name);
                            if (skill) {
                                itemToPick = {
                                    ...itemToPick,
                                    effect: skill.effect
                                };
                                droppedItem.item = itemToPick; // Update the droppedItem too
                                break;
                            }
                        }

                        // If not found in skills, check NPCs (for NPC-specific abilities)
                        if (!itemToPick.effect) {
                            const npcWithAbility = npcs.find(n => n.abilityName === itemToPick.name);
                            if (npcWithAbility && npcWithAbility.abilityEffect) {
                                itemToPick = {
                                    ...itemToPick,
                                    effect: npcWithAbility.abilityEffect
                                };
                                droppedItem.item = itemToPick; // Update the droppedItem too
                            }
                        }
                    }

                    player.carryingItems.push(itemToPick);
                    droppedItem.collected = true;

                    // Play random pickup sound
                    const randomPickup = audio.pickupSounds[Math.floor(Math.random() * audio.pickupSounds.length)];
                    randomPickup.currentTime = 0;
                    randomPickup.play();
                }
            }

            // Check NPC proximity for interactions (only when not in cooldown)
            if (!dialogue.active && dialogue.cooldownTimer <= 0) {
                for (let npc of npcs) {
                    const dx = player.x - npc.x;
                    const dy = player.y - npc.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < player.radius + npc.radius + 30 && isOnScreen(npc.x, npc.y)) {
                        // Check for package delivery before dialogue
                        for (let i = 0; i < player.carryingItems.length; i++) {
                            const item = player.carryingItems[i];
                            if (item.type === 'package' && item.targetNpc === npc.name) {
                                // Deliver the package
                                player.carryingItems.splice(i, 1);

                                // Mark NPC as completed (turns white)
                                npc.hasCompletedQuest = true;

                                // Increment delivery count if jobs system has courier
                                if (jobs.hasCourier) {
                                    jobs.courierDeliveriesToday++;

                                    // Mark first delivery as made
                                    const weadon = npcs.find(n => n.name === 'Weadon');
                                    if (weadon && !weadon.firstDeliveryMade) {
                                        weadon.firstDeliveryMade = true;
                                    }

                                    // Give diamond as payment for delivery
                                    if (player.carryingItems.length < modifiers.carryCapacity) {
                                        player.carryingItems.push({
                                            type: 'diamond',
                                            coinValue: 10,
                                            slowAmount: 10
                                        });
                                    }
                                }

                                // Play received gift sound
                                audio.receivedGift.currentTime = 0;
                                audio.receivedGift.play();

                                // Clear current package from jobs
                                if (jobs.currentPackage === item) {
                                    jobs.currentPackage = null;
                                    jobs.packageDeadline = null;
                                }

                                break;
                            }
                        }

                        // Weadon giving packages
                        if (npc.name === 'Weadon' && jobs.hasCourier && jobs.currentPackage === null && jobs.courierDeliveriesToday < 3) {
                            // Check if it's after 8am today
                            const now = new Date();
                            const hour = now.getHours();

                            if (hour >= 8) {
                                // Give random package
                                const eligibleNpcs = npcs.filter(n => n.name !== 'Weadon');
                                const randomNpc = eligibleNpcs[Math.floor(Math.random() * eligibleNpcs.length)];
                                const weight = 5 + Math.floor(Math.random() * 6); // 5-10
                                givePackageToPlayer(randomNpc.name, weight);
                            }
                        }

                        // If NPC is collecting coins and player has coins, take them
                        if (npc.isCollecting && !npc.itemGiven && player.carryingCoins.length > 0) {
                            const coinsNeeded = npc.requiresCoins - npc.coinsCollected;
                            const coinsToTake = Math.min(player.carryingCoins.length, coinsNeeded);

                            for (let i = 0; i < coinsToTake; i++) {
                                player.carryingCoins.pop();
                            }

                            npc.coinsCollected += coinsToTake;

                            // Play coin payment sound
                            const randomPickup = audio.pickupSounds[Math.floor(Math.random() * audio.pickupSounds.length)];
                            randomPickup.currentTime = 0;
                            randomPickup.play();

                            // Check if we have enough coins now
                            if (npc.coinsCollected >= npc.requiresCoins) {
                                npc.isCollecting = false;
                                giveItemToPlayer(npc);
                                // Don't start dialogue, just give item
                                continue;
                            } else {
                                // Show collecting dialogue
                                startDialogue(npc);
                                return;
                            }
                        }

                        // If Ram is collecting diamond and player has a regular diamond
                        if (npc.isCollectingDiamond && !npc.itemGiven) {
                            // Find a regular diamond (any diamond except the White Diamond/Golden Fleece which has slowAmount: 100)
                            const diamondIndex = player.carryingItems.findIndex(item =>
                                item.type === 'diamond' &&
                                item.slowAmount !== 100 &&
                                item.name !== 'White Diamond'
                            );

                            if (diamondIndex !== -1) {
                                // Remove the diamond from player
                                player.carryingItems.splice(diamondIndex, 1);

                                // Play payment sound
                                audio.receivedGift.currentTime = 0;
                                audio.receivedGift.play();

                                // Give item to player
                                npc.isCollectingDiamond = false;
                                giveItemToPlayer(npc);
                                continue;
                            }
                        }

                        // Don't re-trigger if this is the NPC we just talked to (unless they're collecting)
                        if (dialogue.lastNpc === npc && !npc.isCollecting) {
                            continue;
                        }

                        // Start normal dialogue
                        if (!npc.isCollecting || player.carryingCoins.length === 0) {
                            startDialogue(npc);
                            return; // Only one NPC at a time
                        }
                    }
                }

                // Reset lastNpc if player moved away from all NPCs
                let nearAnyNpc = false;
                for (let npc of npcs) {
                    const dx = player.x - npc.x;
                    const dy = player.y - npc.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < player.radius + npc.radius + 30) {
                        nearAnyNpc = true;
                        break;
                    }
                }
                if (!nearAnyNpc) {
                    dialogue.lastNpc = null;
                }
            }

            // Return coins and items to post
            if (player.carryingCoins.length > 0 || player.carryingItems.length > 0) {
                const dxPost = player.x - post.x;
                const dyPost = player.y - post.y;
                const distPost = Math.sqrt(dxPost * dxPost + dyPost * dyPost);

                if (distPost < player.radius + post.radius + 5) {
                    // Deposit coins
                    if (player.carryingCoins.length > 0) {
                        const coinsDeposited = player.carryingCoins.length;

                        // Extend chain for each coin
                        for (let i = 0; i < coinsDeposited; i++) {
                            chain.links++;
                            chain.segments.push({ x: player.x, y: player.y });
                        }

                        game.coinsDeposited += coinsDeposited;
                        player.carryingCoins = [];

                        // Camera bounce effect
                        game.cameraShakeAmount = 0.15;

                        // Add floating text
                        floatingTexts.push({
                            text: '+' + coinsDeposited,
                            x: post.x,
                            y: post.y - post.radius - 10,
                            vy: -1.5,
                            alpha: 1.0,
                            life: 1.0
                        });

                        // Play deposit sound
                        audio.depositCoin.currentTime = 0;
                        audio.depositCoin.play();

                        // Ensure there's always a reachable coin
                        ensureReachableCoin();

                        // Save game
                        saveGame();
                    }

                    // Deposit items (find first non-package item)
                    const itemIndex = player.carryingItems.findIndex(i => i.type !== 'package');
                    if (itemIndex !== -1) {
                        const item = player.carryingItems[itemIndex];

                        if (item.type === 'diamond') {
                            // Add diamond value to coins
                            for (let i = 0; i < item.coinValue; i++) {
                                chain.links++;
                                chain.segments.push({ x: player.x, y: player.y });
                            }
                            game.coinsDeposited += item.coinValue;

                            // Add floating text
                            floatingTexts.push({
                                text: '+' + item.coinValue,
                                x: post.x,
                                y: post.y - post.radius - 10,
                                vy: -1.5,
                                alpha: 1.0,
                                life: 1.0
                            });

                            audio.depositCoin.currentTime = 0;
                            audio.depositCoin.play();

                        } else if (item.type === 'ability') {
                            // Apply ability
                            item.effect();

                            // Show ability display
                            game.currentAbilityText = item.name;
                            game.showAbilityDisplay = true;
                            game.abilityDisplayTimer = 0;
                            game.paused = true;

                            audio.depositSpecial.currentTime = 0;
                            audio.depositSpecial.play();

                        } else if (item.type === 'homeBeacon') {
                            // Activate home beacon
                            game.hasHomeBeacon = true;

                            // Show ability display
                            game.currentAbilityText = 'Home Beacon';
                            game.showAbilityDisplay = true;
                            game.abilityDisplayTimer = 0;
                            game.paused = true;

                            audio.depositSpecial.currentTime = 0;
                            audio.depositSpecial.play();

                        } else if (item.type === 'musicDisk') {
                            // Add disk to collected disks if not already there
                            const diskExists = collectedDisks.some(d => d.name === item.name);
                            if (!diskExists) {
                                collectedDisks.push({
                                    name: item.name,
                                    trackPaths: item.trackPaths
                                });
                            }

                            // Set this disk as current
                            currentDiskIndex = collectedDisks.findIndex(d => d.name === item.name);

                            // Clear any existing music points at post
                            for (let i = musicPoints.length - 1; i >= 0; i--) {
                                if (musicPoints[i].x === post.x && musicPoints[i].y === post.y) {
                                    musicPoints[i].audioTracks.forEach(audio => audio.pause());
                                    musicPoints.splice(i, 1);
                                }
                            }

                            // Create new music point with the deposited disk (3000 range)
                            addMusicPoint(post.x, post.y, item.trackPaths, 3000, item.name);

                            // Show ability display
                            game.currentAbilityText = item.name;
                            game.showAbilityDisplay = true;
                            game.abilityDisplayTimer = 0;
                            game.paused = true;

                            audio.depositSpecial.currentTime = 0;
                            audio.depositSpecial.play();

                        } else if (item.type === 'workTools') {
                            // Activate work tools
                            game.hasWorkTools = true;

                            // Show ability display
                            game.currentAbilityText = 'Work Tools';
                            game.showAbilityDisplay = true;
                            game.abilityDisplayTimer = 0;
                            game.paused = true;

                            audio.depositSpecial.currentTime = 0;
                            audio.depositSpecial.play();
                        }

                        // Remove the deposited item
                        player.carryingItems.splice(itemIndex, 1);

                        // Camera bounce
                        game.cameraShakeAmount = 0.15;

                        // Save game AFTER item is removed from inventory
                        saveGame();
                    }
                }
            }
        }

        // Draw background dots at job locations
        function drawBackgroundDots() {
            const locations = [
                { x: -2000, y: -2500, width: 500, height: 500, spacing: 20 }, // Sorting Grounds
                { x: 2100, y: -2400, width: 600, height: 400, spacing: 20 },  // Courier Depot
                { x: -3000, y: -3000, width: 1000, height: 1000, spacing: 20 } // Farm
            ];

            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            const dotRadius = 2;

            for (let loc of locations) {
                const startX = loc.x - loc.width / 2;
                const startY = loc.y - loc.height / 2;
                const endX = loc.x + loc.width / 2;
                const endY = loc.y + loc.height / 2;

                for (let x = startX; x <= endX; x += loc.spacing) {
                    for (let y = startY; y <= endY; y += loc.spacing) {
                        const screen = worldToScreen(x, y);
                        // Only draw if on screen
                        if (screen.x >= -10 && screen.x <= canvas.width + 10 &&
                            screen.y >= -10 && screen.y <= canvas.height + 10) {
                            ctx.beginPath();
                            ctx.arc(screen.x, screen.y, dotRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
        }

        // Draw visual elements (grass, puddles, footprints, dust)
        function drawVisualElements() {
            // Draw footprints (behind everything)
            for (let fp of footprints) {
                const screen = worldToScreen(fp.x, fp.y);
                if (screen.x < -20 || screen.x > canvas.width + 20 ||
                    screen.y < -20 || screen.y > canvas.height + 20) continue;

                ctx.save();
                ctx.translate(screen.x, screen.y);
                ctx.rotate(fp.angle);
                ctx.fillStyle = `rgba(255, 255, 255, ${fp.alpha})`;

                // Small oval footprint
                ctx.beginPath();
                ctx.ellipse(0, 0, 4 * game.zoom, 2.5 * game.zoom, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw dust particles
            for (let dust of dustParticles) {
                const screen = worldToScreen(dust.x, dust.y);
                if (screen.x < -10 || screen.x > canvas.width + 10 ||
                    screen.y < -10 || screen.y > canvas.height + 10) continue;

                ctx.fillStyle = `rgba(255, 255, 255, ${dust.alpha})`;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, dust.size * game.zoom, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw puddles (outline hidden - ripples only)
            // Puddle areas are invisible, only ripples show when player walks through

            // Draw ripples (horizontal ovals like pond shape)
            for (let ripple of ripples) {
                const screen = worldToScreen(ripple.x, ripple.y);
                if (screen.x < -100 || screen.x > canvas.width + 100 ||
                    screen.y < -100 || screen.y > canvas.height + 100) continue;

                ctx.strokeStyle = `rgba(255, 255, 255, ${ripple.alpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Horizontal oval: wider x radius, compressed y radius (like puddle/pond shape)
                ctx.ellipse(screen.x, screen.y, ripple.radius * game.zoom, ripple.radius * 0.5 * game.zoom, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw grass blades
            ctx.lineCap = 'round';
            for (let grass of grassPatches) {
                const screen = worldToScreen(grass.x, grass.y);
                if (screen.x < -50 || screen.x > canvas.width + 50 ||
                    screen.y < -50 || screen.y > canvas.height + 50) continue;

                const length = grass.length * game.zoom;
                const endX = screen.x + Math.cos(grass.currentAngle) * length;
                const endY = screen.y + Math.sin(grass.currentAngle) * length;

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.lineWidth = 1 * game.zoom;
                ctx.beginPath();
                ctx.moveTo(screen.x, screen.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }

        // Render
        function render() {
            // Day/Night visual - invert colors during daytime (6am-6pm)
            const now = new Date();
            const hours = now.getHours();
            const isDaytime = hours >= 6 && hours < 18;
            canvas.style.filter = isDaytime ? 'invert(1)' : 'none';

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground grid dots
            const gridSpacing = 100; // Denser spacing
            const dotRadius = 2;
            const startX = Math.floor((player.x - canvas.width / (2 * game.zoom)) / gridSpacing) * gridSpacing;
            const startY = Math.floor((player.y - canvas.height / (2 * game.zoom)) / gridSpacing) * gridSpacing;
            const endX = player.x + canvas.width / (2 * game.zoom);
            const endY = player.y + canvas.height / (2 * game.zoom);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            for (let x = startX; x <= endX; x += gridSpacing) {
                for (let y = startY; y <= endY; y += gridSpacing) {
                    const screen = worldToScreen(x, y);
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, dotRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw background dots at job locations
            drawBackgroundDots();

            // Draw visual elements (grass, puddles, footprints, dust)
            drawVisualElements();

            // Draw barriers
            for (let barrier of barriers) {
                const topLeft = worldToScreen(barrier.x, barrier.y);
                const width = barrier.width * game.zoom;
                const height = barrier.height * game.zoom;

                // Draw black fill
                ctx.fillStyle = '#000';
                ctx.fillRect(topLeft.x, topLeft.y, width, height);

                // Draw white outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(topLeft.x, topLeft.y, width, height);
            }

            // Draw coins (only non-collected ones)
            for (let coin of coins) {
                if (coin.collected) continue;

                const screen = worldToScreen(coin.x, coin.y);
                ctx.fillStyle = coin.color;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, coin.radius * game.zoom, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw dropped items (only non-collected ones)
            for (let droppedItem of droppedItems) {
                if (droppedItem.collected) continue;

                const screen = worldToScreen(droppedItem.x, droppedItem.y);
                ctx.fillStyle = droppedItem.color;
                ctx.strokeStyle = droppedItem.outlineColor;
                ctx.lineWidth = 2 * game.zoom;

                if (droppedItem.item && droppedItem.item.type === 'package') {
                    // Draw packages as squares
                    const size = droppedItem.radius * 2 * game.zoom;
                    ctx.fillRect(screen.x - size/2, screen.y - size/2, size, size);
                    ctx.strokeRect(screen.x - size/2, screen.y - size/2, size, size);
                } else {
                    // Draw other items as circles
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, droppedItem.radius * game.zoom, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            // Draw Pin's chain
            ctx.fillStyle = '#888';
            for (let seg of pinChain.segments) {
                const screen = worldToScreen(seg.x, seg.y);
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, 3 * game.zoom, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw Pin's post
            const pinPostScreen = worldToScreen(pinPost.x, pinPost.y);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(pinPostScreen.x, pinPostScreen.y, pinPost.baseRadius * game.zoom, 0, Math.PI * 2);
            ctx.fill();

            // Draw Brot's chain
            ctx.fillStyle = '#888';
            for (let seg of brotChain.segments) {
                const screen = worldToScreen(seg.x, seg.y);
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, 3 * game.zoom, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw Brot's post
            const brotPostScreen = worldToScreen(brotPost.x, brotPost.y);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(brotPostScreen.x, brotPostScreen.y, brotPost.baseRadius * game.zoom, 0, Math.PI * 2);
            ctx.fill();

            // Draw Brot's animals (triangles in Brot's zone - white fill)
            for (let animal of brotAnimals) {
                const screen = worldToScreen(animal.x, animal.y);
                ctx.fillStyle = '#fff'; // White when in Brot's zone
                ctx.strokeStyle = '#000'; // Black outline
                ctx.lineWidth = 2;
                ctx.beginPath();
                const size = animal.radius * game.zoom;
                ctx.moveTo(screen.x, screen.y - size);
                ctx.lineTo(screen.x - size * 0.866, screen.y + size * 0.5);
                ctx.lineTo(screen.x + size * 0.866, screen.y + size * 0.5);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Draw chain as minimal circles
            ctx.fillStyle = '#888';
            for (let seg of chain.segments) {
                const screen = worldToScreen(seg.x, seg.y);
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, 3 * game.zoom, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw post with color fade (white to black)
            const postScreen = worldToScreen(post.x, post.y);

            // Calculate color based on pulse (fade from white to black)
            let grayValue = 255; // Start at white
            if (player.carryingCoins.length > 0 || player.carryingItems.length > 0) {
                // Pulse between white (255) and black (0)
                grayValue = Math.floor(255 * post.alpha);
            }

            ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
            ctx.beginPath();
            ctx.arc(postScreen.x, postScreen.y, post.baseRadius * game.zoom, 0, Math.PI * 2);
            ctx.fill();

            // Draw player
            const playerScreen = worldToScreen(player.x, player.y);

            // Blink effect when Max Fulfillment boost is active
            let playerFillColor = player.color;
            let playerStrokeColor = player.outlineColor;
            if (game.maxFulfillmentBoostActive) {
                const blinkRate = Math.sin(Date.now() * 0.015) > 0;
                playerFillColor = blinkRate ? '#fff' : player.color;
                playerStrokeColor = blinkRate ? player.color : player.outlineColor;
            }

            ctx.fillStyle = playerFillColor;
            ctx.beginPath();
            ctx.arc(playerScreen.x, playerScreen.y, player.radius * game.zoom, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = playerStrokeColor;
            ctx.lineWidth = 2 * game.zoom;
            ctx.stroke();

            // Draw carried coins (stacked)
            let stackIndex = 0;
            for (let i = 0; i < player.carryingCoins.length; i++) {
                const coin = player.carryingCoins[i];
                const stackOffset = (player.radius + 8 + stackIndex * 12) * game.zoom;
                ctx.fillStyle = coin.color;
                ctx.beginPath();
                ctx.arc(playerScreen.x, playerScreen.y - stackOffset, coin.radius * game.zoom, 0, Math.PI * 2);
                ctx.fill();
                stackIndex++;
            }

            // Draw carried items (stacked above coins) - all items are black with white outline
            for (let i = 0; i < player.carryingItems.length; i++) {
                const item = player.carryingItems[i];
                const stackOffset = (player.radius + 8 + stackIndex * 12) * game.zoom;

                // All items are black with white outline
                ctx.fillStyle = '#000';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2 * game.zoom;

                if (item.type === 'package') {
                    // Draw packages as squares
                    const size = 16 * game.zoom; // Same diameter as circle (8 * 2)
                    ctx.fillRect(playerScreen.x - size/2, playerScreen.y - stackOffset - size/2, size, size);
                    ctx.strokeRect(playerScreen.x - size/2, playerScreen.y - stackOffset - size/2, size, size);
                } else {
                    // Draw other items as circles
                    ctx.beginPath();
                    ctx.arc(playerScreen.x, playerScreen.y - stackOffset, 8 * game.zoom, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                stackIndex++;
            }

            // Draw NPCs
            const time = Date.now() / 1000;
            for (let npc of npcs) {
                const npcScreen = worldToScreen(npc.x, npc.y);

                // Determine NPC color (blink white if collecting coins or can receive package, white if quest completed, black otherwise)
                let fillColor = npc.color;
                let strokeColor = npc.outlineColor;

                const canReceivePackage = jobs.currentPackage !== null && jobs.currentPackage.targetNpc === npc.name;

                if ((npc.isCollecting && !npc.itemGiven) || (npc.isCollectingDiamond && !npc.itemGiven) || canReceivePackage) {
                    // Blink between white and black
                    const blinkSpeed = 3; // Blinks per second
                    const isWhite = Math.floor(time * blinkSpeed) % 2 === 0;
                    fillColor = isWhite ? '#fff' : '#000';
                    strokeColor = isWhite ? '#fff' : '#fff';
                } else if (npc.hasCompletedQuest) {
                    fillColor = '#fff';
                    strokeColor = '#fff';
                }

                // Draw NPC body
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.arc(npcScreen.x, npcScreen.y, npc.radius * game.zoom, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2 * game.zoom;
                ctx.stroke();

                // Draw wait circle above NPC if player is nearby
                if (dialogue.active && dialogue.npc === npc && dialogue.isWaiting) {
                    const waitY = npcScreen.y - (npc.radius + 25) * game.zoom;
                    const waitRadius = 10 * game.zoom;
                    const waitProgress = dialogue.waitTimer / dialogue.waitDuration;

                    // Draw outline circle
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(npcScreen.x, waitY, waitRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Draw fill circle (progress)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(npcScreen.x, waitY, waitRadius, -Math.PI / 2, -Math.PI / 2 + waitProgress * Math.PI * 2);
                    ctx.lineTo(npcScreen.x, waitY);
                    ctx.fill();
                }
            }

            // Draw farm animals (triangles)
            for (let animal of farmAnimals) {
                const animalScreen = worldToScreen(animal.x, animal.y);

                // Draw triangle pointing upward
                const size = animal.radius * game.zoom;
                ctx.fillStyle = animal.color;
                ctx.strokeStyle = animal.outlineColor;
                ctx.lineWidth = 2 * game.zoom;

                ctx.beginPath();
                // Top point
                ctx.moveTo(animalScreen.x, animalScreen.y - size);
                // Bottom right
                ctx.lineTo(animalScreen.x + size * 0.866, animalScreen.y + size * 0.5);
                // Bottom left
                ctx.lineTo(animalScreen.x - size * 0.866, animalScreen.y + size * 0.5);
                ctx.closePath();

                ctx.fill();
                ctx.stroke();
            }

            // Draw floating texts
            for (let text of floatingTexts) {
                const textScreen = worldToScreen(text.x, text.y);
                ctx.globalAlpha = text.alpha;
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(text.text, textScreen.x, textScreen.y);
                ctx.globalAlpha = 1.0;
            }

            // Draw UI
            ctx.fillStyle = '#fff';
            ctx.font = '16px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Chain Links: ${chain.links}`, 10, 20);
            const totalCarrying = player.carryingCoins.length + player.carryingItems.length;
            const capDisplay = game.maxFulfillmentBoostActive ? `${totalCarrying}/${modifiers.carryCapacity} (3x SPD!)` : `${totalCarrying}/${modifiers.carryCapacity}`;
            ctx.fillText(`Carrying: ${capDisplay}`, 10, 40);
            ctx.fillText(`Press F for fullscreen`, 10, 60);

            // Draw nearby NPC name at bottom center of screen (hide only when reading dialogue box)
            if (game.nearbyNpc && !(dialogue.active && !dialogue.isWaiting)) {
                ctx.font = 'bold 20px monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText(game.nearbyNpc.name, canvas.width / 2, canvas.height - 20);
            }

            // Draw home beacon indicator
            if (game.hasHomeBeacon) {
                const dx = post.x - player.x;
                const dy = post.y - player.y;
                const angle = Math.atan2(dy, dx);

                // Position at edge of screen
                const edgePadding = 30;
                const indicatorX = canvas.width / 2 + Math.cos(angle) * (canvas.width / 2 - edgePadding);
                const indicatorY = canvas.height / 2 + Math.sin(angle) * (canvas.height / 2 - edgePadding);

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw dialogue box
            if (dialogue.active && dialogue.npc && !dialogue.isWaiting) {
                const npc = dialogue.npc;
                let pages = npc.dialogue;
                const totalCarrying = player.carryingCoins.length + player.carryingItems.length;

                // Determine which dialogue to show
                if (npc.itemType === 'straum') {
                    // Straum special dialogue logic
                    if (npc.hasCompletedQuest) {
                        pages = npc.completedDialogue;
                    } else if (dialogue.showingStraumDiamondDeclined && npc.diamondNoDialogue) {
                        pages = npc.diamondNoDialogue;
                    } else if (dialogue.showingStraumDiamond) {
                        // Stay on outOfCoinsDialogue until choice is handled
                        pages = npc.outOfCoinsDialogue;
                    } else if (dialogue.showingStraumDropped && npc.droppedCoinsDialogue) {
                        pages = npc.droppedCoinsDialogue;
                    } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                        pages = npc.declinedDialogue;
                    } else if (npc.coinsInventory === 0 && !npc.diamondGiven) {
                        pages = npc.outOfCoinsDialogue;
                    } else if (playerDroppedCoins && npc.coinsInventory > 0) {
                        pages = npc.droppedCoinsDialogue;
                    }
                } else if (dialogue.showingNeedsWorkTools && npc.needsWorkToolsDialogue) {
                    pages = npc.needsWorkToolsDialogue;
                } else if (npc.name === 'Tim' && npc.needsWorkTools && !npc.workToolsGiven) {
                    pages = npc.workToolsDialogue;
                } else if (npc.name === 'Tim' && npc.workToolsGiven) {
                    pages = npc.workToolsCompletedDialogue;
                } else if (npc.name === 'Wheaton' && npc.jobAccepted && npc.allAnimalsRetrieved) {
                    pages = npc.completedDialogue;
                } else if (npc.name === 'Wheaton' && npc.jobAccepted && npc.firstRetrievalCompleted) {
                    pages = npc.activeJobDialogue;
                } else if (npc.name === 'Wheaton' && npc.jobAccepted && !npc.firstRetrievalCompleted) {
                    pages = npc.retrievalDialogue;
                } else if (npc.name === 'Weadon' && jobs.courierDeliveriesToday >= 3) {
                    pages = npc.completedDeliveriesDialogue;
                } else if (npc.name === 'Weadon' && jobs.currentPackage !== null) {
                    const deadline = jobs.packageDeadline;
                    const timeString = deadline ? `${deadline.getHours().toString().padStart(2, '0')}:${deadline.getMinutes().toString().padStart(2, '0')}` : 'UNKNOWN';
                    const targetNpcName = jobs.currentPackage.targetNpc || 'UNKNOWN';
                    pages = npc.activeDeliveryDialogue.map(page =>
                        page.map(sentence => sentence.replace('TIME_PLACEHOLDER', timeString).replace('NPC_PLACEHOLDER', targetNpcName))
                    );
                } else if (npc.name === 'Weadon' && npc.jobAccepted && !npc.firstDeliveryMade) {
                    pages = npc.firstPackageDialogue;
                } else if (npc.name === 'Pin') {
                    // Pin's progressive dialogue based on chain length
                    if (pinChain.links >= 100 && npc.diamondGiven) {
                        pages = npc.completedDialogue;
                    } else if (pinChain.links >= 100 && !npc.diamondGiven) {
                        pages = npc.hundredLinksDialogue;
                    } else if (pinChain.links >= 50) {
                        pages = npc.fiftyLinksDialogue;
                    } else if (pinChain.links >= 20) {
                        pages = npc.twentyLinksDialogue;
                    } else if (pinChain.links >= 10) {
                        pages = npc.tenLinksDialogue;
                    } else {
                        pages = npc.dialogue;
                    }
                } else if (npc.name === 'Klaus') {
                    // Klaus only gives disk when Pin has 50+ links
                    if (npc.itemGiven) {
                        pages = npc.completedDialogue;
                    } else if (pinChain.links >= 50) {
                        pages = npc.pinReadyDialogue;
                    } else {
                        pages = npc.dialogue;
                    }
                } else if (npc.name === 'Brot') {
                    // Brot's progressive dialogue based on animals collected
                    if (npc.hasCompletedQuest) {
                        pages = npc.completedDialogue;
                    } else if (npc.animalsCollected >= 50 && !npc.itemGiven) {
                        pages = npc.fiftyAnimalsDialogue;
                    } else if (npc.animalsCollected >= 25) {
                        pages = npc.twentyFiveAnimalsDialogue;
                    } else if (npc.animalsCollected >= 10) {
                        pages = npc.tenAnimalsDialogue;
                    } else if (npc.animalsCollected >= 5) {
                        pages = npc.fiveAnimalsDialogue;
                    } else if (npc.animalsCollected >= 1) {
                        pages = npc.oneAnimalDialogue;
                    } else {
                        pages = npc.dialogue;
                    }
                } else if (npc.name === 'Noodles') {
                    // Noodles only gives disk when player chain has 750+ links
                    if (npc.itemGiven) {
                        pages = npc.completedDialogue;
                    } else if (chain.links >= 750) {
                        pages = npc.linksReadyDialogue;
                    } else {
                        pages = npc.dialogue;
                    }
                } else if (npc.name === 'Clint') {
                    // Clint's dialogue depends on following state
                    if (dialogue.showingYesDialogue && npc.yesDialogue) {
                        pages = npc.yesDialogue;
                    } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                        pages = npc.declinedDialogue;
                    } else if (npc.isFollowing) {
                        pages = npc.followingDialogue;
                    } else {
                        pages = npc.dialogue;
                    }
                } else if (npc.name === 'Ram') {
                    // Ram's dialogue handling
                    if (npc.itemGiven) {
                        pages = npc.completedDialogue;
                    } else if (dialogue.showingNoDiamondDialogue && npc.noDiamondDialogue) {
                        pages = npc.noDiamondDialogue;
                    } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                        pages = npc.declinedDialogue;
                    } else if (totalCarrying >= modifiers.carryCapacity && npc.fullDialogue) {
                        pages = npc.fullDialogue;
                    } else {
                        pages = npc.dialogue;
                    }
                } else if (npc.itemGiven) {
                    pages = npc.completedDialogue;
                } else if (npc.isCollecting && npc.collectingDialogue) {
                    // NPC is collecting coins - show progress
                    pages = npc.collectingDialogue.map(page =>
                        page.map(sentence => sentence.replace('X', npc.requiresCoins - npc.coinsCollected))
                    );
                } else if (dialogue.showingDeclinedDialogue && npc.declinedDialogue) {
                    pages = npc.declinedDialogue;
                } else if (npc.itemType && totalCarrying >= modifiers.carryCapacity && npc.fullDialogue) {
                    pages = npc.fullDialogue;
                }

                const currentPageData = pages[dialogue.currentPage] || pages[0];

                // Draw black dialogue box at bottom
                const boxHeight = 150;
                const boxY = canvas.height - boxHeight;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, boxY, canvas.width, boxHeight);

                // Draw white border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, boxY, canvas.width, boxHeight);

                // Draw NPC name
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(npc.name, 20, boxY + 30);

                // Draw dialogue text (3 sentences per page)
                ctx.font = '16px monospace';
                let textY = boxY + 60;
                for (let sentence of currentPageData) {
                    ctx.fillText(sentence, 20, textY);
                    textY += 25;
                }

                // Draw navigation hint
                ctx.font = '12px monospace';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#888';
                if (dialogue.pendingChoice) {
                    ctx.fillText('Up: Yes | Down: No', canvas.width - 20, boxY + boxHeight - 10);
                } else {
                    ctx.fillText('Left: Back | Right: Next', canvas.width - 20, boxY + boxHeight - 10);
                }
            }

            // Draw ability display
            if (game.showAbilityDisplay) {
                // Semi-transparent overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Title
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 36px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ABILITY RECEIVED', centerX, centerY - 50);

                // Ability name
                ctx.font = 'bold 24px monospace';
                ctx.fillText(game.currentAbilityText, centerX, centerY + 20);

                // Show countdown
                const timeRemaining = game.abilityDisplayDelay - game.abilityDisplayTimer;
                ctx.font = 'bold 20px monospace';
                ctx.fillStyle = '#fff';
                ctx.fillText(`[ ${Math.ceil(timeRemaining)} ]`, centerX, centerY + 80);
            }

            // Draw work tools HUD elements (only if player has work tools)
            if (game.hasWorkTools) {
                // Get current time
                const now = new Date();
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                const isDaytime = hours >= 6 && hours < 18;

                // Draw clock and day/night indicator at top center
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';

                // Draw day/night icon (using text symbols that respect fillStyle color)
                const dayNightIcon = isDaytime ? '☀' : '☽';
                ctx.fillText(`${dayNightIcon} ${timeString}`, canvas.width / 2, 25);

                // Draw player coordinates in top right
                ctx.font = '14px monospace';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#fff';
                ctx.fillText(`(${Math.round(player.x)}, ${Math.round(player.y)})`, canvas.width - 10, 20);
            }

            // Draw current track name under coordinates (only when in range of music)
            const postMusicPoint = musicPoints.find(point => point.x === post.x && point.y === post.y);
            if (postMusicPoint && postMusicPoint.currentVolume > 0) {
                // Get the currently playing track file name with extension
                const currentTrackIndex = postMusicPoint.currentTrackIndex || 0;
                const trackPath = postMusicPoint.audioTracks[currentTrackIndex].src.split('/').pop();

                ctx.font = '14px monospace';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#fff';
                ctx.fillText(`${postMusicPoint.diskName}: ${trackPath}`, canvas.width - 10, 40);
            }

            // Draw reset progress indicator when holding R
            if (resetHoldTimer > 0) {
                const progress = resetHoldTimer / RESET_HOLD_DURATION;
                const barWidth = 200;
                const barHeight = 20;
                const barX = (canvas.width - barWidth) / 2;
                const barY = canvas.height - 60;

                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);

                // Progress fill
                ctx.fillStyle = '#fff';
                ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * progress, barHeight - 4);

                // Text
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.fillText('Hold R to reset save...', canvas.width / 2, barY - 10);
            }
        }

        // Spawn farm animals (triangles)
        function spawnFarmAnimals() {
            farmAnimals.length = 0; // Clear existing

            // Spawn 50 animals in the area (-1000, -2500) to (1000, -3000)
            for (let i = 0; i < 50; i++) {
                farmAnimals.push({
                    x: -1000 + Math.random() * 2000, // -1000 to 1000
                    y: -2500 + Math.random() * -500, // -2500 to -3000
                    radius: 8,
                    color: '#000',
                    outlineColor: '#fff',
                    following: false,
                    targetX: 0,
                    targetY: 0
                });
            }
        }

        // Update farm animals physics
        function updateFarmAnimals() {
            // Only allow following if player has job and work tools
            const wheaton = npcs.find(n => n.name === 'Wheaton');
            const canFollow = wheaton && wheaton.jobAccepted && game.hasWorkTools;

            // Calculate player's current speed (slightly slower for animals - 90%)
            const playerSpeed = player.baseSpeed * (1 + modifiers.moveSpeed);
            const animalSpeed = playerSpeed * 0.9;

            // Count how many animals are currently following
            let followingCount = 0;
            for (let animal of farmAnimals) {
                if (animal.following) followingCount++;
            }

            // Check each animal
            for (let i = 0; i < farmAnimals.length; i++) {
                const animal = farmAnimals[i];
                const dx = player.x - animal.x;
                const dy = player.y - animal.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Start following if within 12px radius and less than 10 are following (or unlimited with Air of Confidence)
                const maxFollowing = game.hasAirOfConfidence ? Infinity : 10;
                if (!animal.following && canFollow && dist <= 12 && followingCount < maxFollowing) {
                    animal.following = true;
                    followingCount++;
                }

                // If following, move towards target in a line formation
                if (animal.following) {
                    // Calculate position in line - animals follow the player or the animal ahead
                    let targetX, targetY;

                    // Find how many animals are following before this one
                    let positionInLine = 0;
                    for (let j = 0; j < i; j++) {
                        if (farmAnimals[j].following) positionInLine++;
                    }

                    // Each animal follows the one ahead, or the player if first
                    if (positionInLine === 0) {
                        targetX = player.x;
                        targetY = player.y;
                    } else {
                        // Find the animal ahead in line
                        let animalAhead = null;
                        let count = 0;
                        for (let j = 0; j < i; j++) {
                            if (farmAnimals[j].following) {
                                if (count === positionInLine - 1) {
                                    animalAhead = farmAnimals[j];
                                    break;
                                }
                                count++;
                            }
                        }
                        if (animalAhead) {
                            targetX = animalAhead.x;
                            targetY = animalAhead.y;
                        } else {
                            targetX = player.x;
                            targetY = player.y;
                        }
                    }

                    // Calculate distance to target
                    const targetDx = targetX - animal.x;
                    const targetDy = targetY - animal.y;
                    const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);

                    // Soft follow using lerp - smoothly interpolate toward target
                    const desiredSpacing = 25;

                    if (targetDist > 0.1) { // Avoid division by zero
                        // Calculate lerp factor based on distance
                        // Faster when far, slower when close for smooth deceleration
                        let lerpFactor;

                        if (targetDist > desiredSpacing * 2) {
                            // Far away - move at full animal speed
                            lerpFactor = animalSpeed / targetDist;
                        } else if (targetDist > desiredSpacing) {
                            // Getting close - ease into position
                            const t = (targetDist - desiredSpacing) / desiredSpacing;
                            lerpFactor = (animalSpeed * t + 0.1 * (1 - t)) / targetDist;
                        } else {
                            // Within desired spacing - gentle drift to maintain formation
                            lerpFactor = 0.08;
                        }

                        // Clamp lerp factor to prevent overshooting
                        lerpFactor = Math.min(lerpFactor, 0.5);

                        // Apply smooth interpolation
                        animal.x += targetDx * lerpFactor;
                        animal.y += targetDy * lerpFactor;
                    }
                }
            }
        }

        // Check if animals near Wheaton should turn into coins
        function checkAnimalRetrieval() {
            const wheaton = npcs.find(n => n.name === 'Wheaton');
            if (!wheaton || !wheaton.jobAccepted || !game.hasWorkTools) return false;

            let convertedAny = false;

            // Check each following animal if within 200px of Wheaton
            for (let i = farmAnimals.length - 1; i >= 0; i--) {
                const animal = farmAnimals[i];

                if (animal.following) {
                    const dx = wheaton.x - animal.x;
                    const dy = wheaton.y - animal.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= 200) {
                        // Convert animal to coin
                        coins.push({
                            x: animal.x,
                            y: animal.y,
                            radius: 8,
                            color: '#fff',
                            collected: false
                        });

                        // Remove animal from array
                        farmAnimals.splice(i, 1);
                        convertedAny = true;

                        // Mark first retrieval as completed
                        if (!wheaton.firstRetrievalCompleted) {
                            wheaton.firstRetrievalCompleted = true;
                        }
                    }
                }
            }

            // Check if all animals have been retrieved
            if (farmAnimals.length === 0 && !wheaton.allAnimalsRetrieved) {
                wheaton.allAnimalsRetrieved = true;
                jobs.retrievedToday = true;
            }

            return convertedAny;
        }

        // Check if following animals enter Brot's 800px zone
        function checkBrotAnimalCapture() {
            const brot = npcs.find(n => n.name === 'Brot');
            if (!brot) return;

            // Check each following animal if within 800px of Brot
            for (let i = farmAnimals.length - 1; i >= 0; i--) {
                const animal = farmAnimals[i];

                if (animal.following) {
                    const dx = brot.x - animal.x;
                    const dy = brot.y - animal.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist <= 800) {
                        // Animal enters Brot's zone - stop following player, become Brot's animal
                        animal.following = false;
                        animal.inBrotZone = true;
                        animal.brotBehaviorState = 'idle'; // 'idle', 'movingToward', 'movingAway'
                        animal.brotIdleTimer = Math.random() * 300 + 300; // 5-10 seconds at 60fps
                        animal.brotTargetX = animal.x;
                        animal.brotTargetY = animal.y;

                        // Move animal to brotAnimals array (permanent)
                        brotAnimals.push(animal);
                        farmAnimals.splice(i, 1);

                        // Increment Brot's animal count
                        brot.animalsCollected++;
                    }
                }
            }
        }

        // Update animals in Brot's zone (wander behavior)
        function updateBrotAnimals() {
            const brot = npcs.find(n => n.name === 'Brot');
            if (!brot) return;

            for (let animal of brotAnimals) {
                // Decrease idle timer
                if (animal.brotBehaviorState === 'idle') {
                    animal.brotIdleTimer--;

                    if (animal.brotIdleTimer <= 0) {
                        // Start moving - randomly toward or away from Brot
                        const moveToward = Math.random() < 0.5;
                        animal.brotBehaviorState = moveToward ? 'movingToward' : 'movingAway';

                        // Pick a target position
                        const angle = Math.random() * Math.PI * 2;
                        let targetDist;

                        if (moveToward) {
                            // Move closer to Brot (100-400px from Brot)
                            targetDist = 100 + Math.random() * 300;
                        } else {
                            // Move away from Brot (400-750px from Brot)
                            targetDist = 400 + Math.random() * 350;
                        }

                        animal.brotTargetX = brot.x + Math.cos(angle) * targetDist;
                        animal.brotTargetY = brot.y + Math.sin(angle) * targetDist;
                    }
                } else {
                    // Moving toward target
                    const dx = animal.brotTargetX - animal.x;
                    const dy = animal.brotTargetY - animal.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 5) {
                        // Reached target, go idle
                        animal.brotBehaviorState = 'idle';
                        animal.brotIdleTimer = Math.random() * 300 + 300; // 5-10 seconds
                    } else {
                        // Move toward target at speed 0.5
                        const moveSpeed = 0.5;
                        animal.x += (dx / dist) * moveSpeed;
                        animal.y += (dy / dist) * moveSpeed;

                        // Clamp to 800px zone
                        const dxBrot = animal.x - brot.x;
                        const dyBrot = animal.y - brot.y;
                        const distBrot = Math.sqrt(dxBrot * dxBrot + dyBrot * dyBrot);
                        if (distBrot > 780) {
                            // Push back inside zone
                            const ratio = 780 / distBrot;
                            animal.x = brot.x + dxBrot * ratio;
                            animal.y = brot.y + dyBrot * ratio;
                            // Go idle when hitting boundary
                            animal.brotBehaviorState = 'idle';
                            animal.brotIdleTimer = Math.random() * 300 + 300;
                        }
                    }
                }
            }
        }

        // Update Brot's chain physics
        function updateBrotChain() {
            const brot = npcs.find(n => n.name === 'Brot');
            if (!brot) return;

            if (brotChain.segments.length === 0) return;

            // Set last segment to Brot's position
            brotChain.segments[brotChain.segments.length - 1].x = brot.x;
            brotChain.segments[brotChain.segments.length - 1].y = brot.y;

            // Apply constraints from Brot back to post
            const iterations = 5;
            for (let iter = 0; iter < iterations; iter++) {
                for (let i = brotChain.segments.length - 2; i >= 0; i--) {
                    const curr = brotChain.segments[i];
                    const next = brotChain.segments[i + 1];
                    const dx = next.x - curr.x;
                    const dy = next.y - curr.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > brotChain.linkLength) {
                        const ratio = brotChain.linkLength / dist;
                        curr.x = next.x - dx * ratio;
                        curr.y = next.y - dy * ratio;
                    }
                }

                brotChain.segments[0].x = brotPost.x;
                brotChain.segments[0].y = brotPost.y;

                for (let i = 1; i < brotChain.segments.length; i++) {
                    const prev = brotChain.segments[i - 1];
                    const curr = brotChain.segments[i];
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > brotChain.linkLength) {
                        const ratio = brotChain.linkLength / dist;
                        curr.x = prev.x + dx * ratio;
                        curr.y = prev.y + dy * ratio;
                    }
                }
            }

            brotChain.segments[0].x = brotPost.x;
            brotChain.segments[0].y = brotPost.y;
            brotChain.segments[brotChain.segments.length - 1].x = brot.x;
            brotChain.segments[brotChain.segments.length - 1].y = brot.y;

            // Final constraint pass
            for (let i = brotChain.segments.length - 2; i >= 0; i--) {
                const curr = brotChain.segments[i];
                const next = brotChain.segments[i + 1];
                const dx = next.x - curr.x;
                const dy = next.y - curr.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > brotChain.linkLength) {
                    const ratio = brotChain.linkLength / dist;
                    curr.x = next.x - dx * ratio;
                    curr.y = next.y - dy * ratio;
                }
            }
        }

        // Update Brot's behavior (collect coins after quest complete)
        function updateBrot() {
            const brot = npcs.find(n => n.name === 'Brot');
            if (!brot) return;

            // Check if player is close enough to stop Brot's movement
            const dx = player.x - brot.x;
            const dy = player.y - brot.y;
            const distToPlayer = Math.sqrt(dx * dx + dy * dy);

            // Stop moving if player is within 50 radius
            if (distToPlayer <= 50) {
                return;
            }

            // Only collect coins after quest is complete
            if (!brot.hasCompletedQuest || brot.refusesToCollectCoins) {
                return;
            }

            // Calculate max chain reach
            const maxChainReach = brotChain.links * brotChain.linkLength;

            // If carrying a coin, return to post
            if (brot.carryingCoin !== null) {
                const dxPost = brotPost.x - brot.x;
                const dyPost = brotPost.y - brot.y;
                const distToPost = Math.sqrt(dxPost * dxPost + dyPost * dyPost);

                if (distToPost < 5) {
                    // Deposit coin and grow chain
                    brotChain.links++;
                    brotChain.segments.push({
                        x: brotPost.x,
                        y: brotPost.y
                    });
                    brot.carryingCoin = null;
                    brot.returningToPost = false;
                    brot.targetCoinIndex = -1;
                } else {
                    // Move toward post at speed 1
                    const moveX = (dxPost / distToPost) * 1;
                    const moveY = (dyPost / distToPost) * 1;
                    const newX = brot.x + moveX;
                    const newY = brot.y + moveY;

                    const newDistToPost = Math.sqrt((newX - brotPost.x) ** 2 + (newY - brotPost.y) ** 2);
                    if (newDistToPost <= maxChainReach) {
                        brot.x = newX;
                        brot.y = newY;
                    }
                }
            } else {
                // Find closest coin
                let closestCoinIndex = -1;
                let closestDist = Infinity;

                for (let i = 0; i < coins.length; i++) {
                    const coin = coins[i];
                    if (coin.collected) continue;

                    const dxCoin = coin.x - brot.x;
                    const dyCoin = coin.y - brot.y;
                    const distToCoin = Math.sqrt(dxCoin * dxCoin + dyCoin * dyCoin);

                    if (distToCoin < closestDist) {
                        closestDist = distToCoin;
                        closestCoinIndex = i;
                    }
                }

                // Move toward closest coin
                if (closestCoinIndex !== -1) {
                    const targetCoin = coins[closestCoinIndex];
                    const dxCoin = targetCoin.x - brot.x;
                    const dyCoin = targetCoin.y - brot.y;
                    const distToCoin = Math.sqrt(dxCoin * dxCoin + dyCoin * dyCoin);

                    if (distToCoin <= brot.radius + targetCoin.radius) {
                        // Pick up the coin
                        brot.carryingCoin = targetCoin;
                        targetCoin.collected = true;
                        brot.returningToPost = true;
                    } else {
                        // Move toward coin at speed 1
                        const moveX = (dxCoin / distToCoin) * 1;
                        const moveY = (dyCoin / distToCoin) * 1;
                        const newX = brot.x + moveX;
                        const newY = brot.y + moveY;

                        const newDistToPost = Math.sqrt((newX - brotPost.x) ** 2 + (newY - brotPost.y) ** 2);
                        if (newDistToPost <= maxChainReach) {
                            brot.x = newX;
                            brot.y = newY;
                        }
                    }
                }
            }
        }

        // Update Clint's following behavior
        function updateClint() {
            const clint = npcs.find(n => n.name === 'Clint');
            if (!clint || !clint.isFollowing) return;

            // Calculate target position to the side of the player
            const sideOffset = 150 * clint.followSide; // 150 units to the side
            const targetX = player.x + sideOffset;
            const targetY = player.y;

            // Calculate distance to target
            const dx = targetX - clint.x;
            const dy = targetY - clint.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Calculate player speed for matching
            const playerSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            const clintSpeed = Math.max(playerSpeed * 0.9, 2); // Match player speed or minimum of 2

            if (dist > 0.1) {
                // Soft follow using lerp - smoothly interpolate toward target
                let lerpFactor;

                if (dist > 100) {
                    // Far away - move at full speed
                    lerpFactor = clintSpeed / dist;
                } else if (dist > 20) {
                    // Getting close - ease into position
                    const t = (dist - 20) / 80;
                    lerpFactor = (clintSpeed * t + 0.1 * (1 - t)) / dist;
                } else {
                    // Within desired distance - gentle drift to maintain formation
                    lerpFactor = 0.08;
                }

                // Clamp lerp factor to prevent overshooting
                lerpFactor = Math.min(lerpFactor, 0.5);

                // Apply smooth interpolation
                clint.x += dx * lerpFactor;
                clint.y += dy * lerpFactor;
            }
        }

        // Check for daily resets
        function checkDailyResets() {
            const now = new Date();
            const today = now.toDateString();

            // Check courier reset (8am)
            if (jobs.courierLastResetDate !== today && now.getHours() >= 8) {
                jobs.courierDeliveriesToday = 0;
                jobs.courierLastResetDate = today;
            }

            // Check sorter reset (6pm)
            if (jobs.sorterLastResetDate !== today && now.getHours() >= 18) {
                if (jobs.hasSorter) {
                    spawnFarmAnimals();
                    // Reset retrieval status
                    const wheaton = npcs.find(n => n.name === 'Wheaton');
                    if (wheaton) {
                        wheaton.allAnimalsRetrieved = false;
                    }
                }
                jobs.sortedToday = false;
                jobs.retrievedToday = false;
                jobs.sorterLastResetDate = today;
            }
        }

        // Game loop
        function gameLoop() {
            // Update cooldown timer
            if (dialogue.cooldownTimer > 0) {
                dialogue.cooldownTimer -= 1/60;
            }

            // Handle reset save by holding R
            if (game.keys.r || game.keys.R) {
                resetHoldTimer += 1/60;
                if (resetHoldTimer >= RESET_HOLD_DURATION) {
                    // Clear save and reload page
                    localStorage.removeItem('chainGameSave');
                    location.reload();
                }
            } else {
                resetHoldTimer = 0;
            }

            // Handle disk switching by holding Up+Down
            if (collectedDisks.length > 0 && (game.keys.ArrowUp || game.keysPressed.ArrowUp) && (game.keys.ArrowDown || game.keysPressed.ArrowDown)) {
                diskSwitchHoldTimer += 1/60;
                if (diskSwitchHoldTimer >= DISK_SWITCH_HOLD_DURATION && !diskSwitchTriggered) {
                    switchDisk();
                    diskSwitchTriggered = true;
                }
            } else {
                diskSwitchHoldTimer = 0;
                diskSwitchTriggered = false;
            }

            // Update music volumes based on player position
            updateMusicVolumes();

            // Always check for nearby NPCs (for name display)
            game.nearbyNpc = null;
            for (let npc of npcs) {
                const dx = player.x - npc.x;
                const dy = player.y - npc.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < player.radius + npc.radius + 30) {
                    game.nearbyNpc = npc;
                    break;
                }
            }

            if (!game.paused) {
                // Check daily resets
                checkDailyResets();

                // Check animal retrieval
                checkAnimalRetrieval();
                updateClint();

                updateCamera();
                updatePost();
                updateFloatingTexts();
                updateFarmAnimals();
                updateVisualElements();
                updateMaxFulfillmentBoost();
                updatePlayer();
                updateChain();
                updatePin();
                updatePinChain();
                updateBrot();
                updateBrotChain();
                updateBrotAnimals();
                checkBrotAnimalCapture();
                checkCoins();
            } else if (game.showAbilityDisplay) {
                updateAbilityDisplay();
            } else if (dialogue.active && dialogue.isWaiting) {
                // Check if player is still near the NPC
                if (dialogue.npc) {
                    const dx = player.x - dialogue.npc.x;
                    const dy = player.y - dialogue.npc.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // If player moved away from NPC, cancel dialogue
                    if (dist > player.radius + dialogue.npc.radius + 30) {
                        endDialogue();
                    } else if (isOnScreen(dialogue.npc.x, dialogue.npc.y)) {
                        // Only update timer if still near and on screen
                        dialogue.waitTimer += 1/60;
                        if (dialogue.waitTimer >= dialogue.waitDuration) {
                            dialogue.isWaiting = false;
                            // Keep game paused for dialogue reading
                        }
                    }
                }
                // Still allow player movement during wait
                updatePlayer();
                updateChain();
                updatePinChain();
                updateBrotChain();
            } else if (dialogue.active && !dialogue.isWaiting) {
                // Check if player is still near the NPC while reading dialogue
                if (dialogue.npc) {
                    const dx = player.x - dialogue.npc.x;
                    const dy = player.y - dialogue.npc.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // If player moved away from NPC, cancel dialogue
                    if (dist > player.radius + dialogue.npc.radius + 30) {
                        endDialogue();
                    }
                }
                // Allow player movement while reading dialogue
                updateCamera();
                updatePost();
                updateFloatingTexts();
                updatePlayer();
                updateChain();
                updatePinChain();
                updateBrotChain();
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        // Initialize and start
        initChain();
        initPinChain();
        initBrotChain();
        initMusic();
        initVisualElements();

        // Try to load save, otherwise init new game
        const saveLoaded = loadGame();
        if (!saveLoaded) {
            initCoins();
        }

        gameLoop();
    </script>
</body>
</html>